# Administración y aseguramiento de la información:
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.
- Identificación del software instalado mediante comandos y herramientas gráficas.
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.
- Implementación RAID por software:
  - Operaciones con volúmenes: extender y distribuir.
  - Aumentar la velocidad.
  - Tolerancia a fallos. Simular un fallo de disco para comprobar la tolerancia del sistema.
  - Detectar fallos consultando los registros del sistema.
  - Programar alertas por correo.
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

---------------------

# Sistema de archivos

## Introducción a sistema de archivos
* https://www.jesusninoc.com/2017/07/04/4-gestion-del-sistema-de-archivos-en-powershell/

# Sistema de archivos: discos
* https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Discos

## Comandos para trabajar con discos en Linux
* https://www.jesusninoc.com/10/28/comandos-para-trabajar-con-discos-en-linux-2/

---------------
---------------

# Examen de noviembre

## Tener en cuenta:
- Utilizar ficheros para leer la información
- Almacenar información en ficheros de log
- Utilizar variables
- Foreach

## Preguntas:
### - Leer identificadores de procesos y comprobar que tienen un proceso
* https://www.jesusninoc.com/10/28/ejercicios-de-powershell-leer-identificadores-de-procesos-y-comprobar-que-tienen-un-proceso/

### - Detectar si hay un tipo de proceso y producto de software que se llame "Acrobat"
* https://www.jesusninoc.com/10/28/ejercicios-de-powershell-detectar-si-hay-un-tipo-de-proceso-y-producto-de-software-que-se-llame-acrobat/

### - Detectar que se está consumiendo tráfico de red por parte de un proceso
* https://www.jesusninoc.com/10/28/ejercicios-de-powershell-detectar-que-se-esta-consumiendo-trafico-de-red-por-parte-de-un-proceso/

### - Detectar que un proceso está utilizando el posicinamiento GPS
```PowerShell
Get-Process | select *
Get-Process -name chrome | Select-Object path
Get-WmiObject win32_process | select *
(Get-WmiObject win32_process | select CommandLine).CommandLine | Select-String "gp"
(Get-WmiObject win32_process | select CommandLine).CommandLine | Select-String "gps"
```

-------------
-------------

# Repaso de examen
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-11-05.md#examen-de-noviembre
## Solución complicada
* https://github.com/jesusninoc/ClasesSAD/blob/master/2020-11-06.md#caso-me-est%C3%A1n-espiando

-----------
-----------

#  IF en PowerShell
* https://www.jesusninoc.com/07/02/2-programacion-en-powershell/#Sentencias_condicionales

# Ejemplos con IF

## Pedir al usuario un nombre de usuario y un password
* https://www.jesusninoc.com/11/23/ejercicios-de-powershell-pedir-al-usuario-un-nombre-de-usuario-y-un-password/

## Pedir al usuario un nombre de usuario y un password y comprobar si es "juan"
* https://www.jesusninoc.com/10/28/ejercicios-de-powershell-pedir-al-usuario-un-nombre-de-usuario-y-un-password-y-comprobar-si-es-juan/

## Pedir al usuario un nombre de usuario y un password y comprobar si es "juan". Introducir pass y ver si es correcto
* https://www.jesusninoc.com/10/28/ejercicios-de-powershell-pedir-al-usuario-un-nombre-de-usuario-y-un-password-y-comprobar-si-es-juan-introducir-pass-y-ver-si-es-correcto/

---------------

# Switch en PowerShell
* https://www.jesusninoc.com/2016/08/09/sentencia-condicional-switch/

# Ejemplos
## Ejemplos sobre operaciones con switch
```PowerShell
$a=Read-Host "Introduzca operación"
switch($a){
'+'{
echo Suma
break
}
}
```
## Pedir una operación y si es "suma" realizar una suma
```PowerShell
$a=Read-Host "Introduzca operación"
switch($a){
'+'{
suma
break
}
}

function suma()
{
2+3
}
```

-----------
-----------

# Ejercicios

## Crear dos ficheros TXT, convertirlos a PDF y juntarlos con Poppler
* https://www.jesusninoc.com/11/26/ejercicios-de-powershell-crear-dos-ficheros-txt-convertirlos-a-pdf-y-juntarlos-con-poppler-utilizando-wsl/

## Crear cinco directorios y dentro de cada directorio crear 10 ficheros
* https://www.jesusninoc.com/11/28/ejercicios-de-powershell-crear-cinco-directorios-y-dentro-de-cada-directorio-crear-10-ficheros/

## Crear una estructura de directorios
* https://www.jesusninoc.com/11/28/ejercicios-de-powershell-crear-una-estructura-de-directorios/

## Crear una estructura de directorios (pero solo los números pares)
* https://www.jesusninoc.com/11/28/ejercicios-de-powershell-crear-una-estructura-de-directorios-pero-solo-los-numeros-pares/

## Crear una estructura de directorios (pero solo los números impares)
* https://www.jesusninoc.com/11/30/ejercicios-de-powershell-crear-una-estructura-de-directorios-pero-solo-los-numeros-impares/

## Leer operaciones de un fichero y realizarlas

### Estructura del fichero asignaturas.txt (0 crear fichero, 1 crear directorio)
```
iso,0
aso,1
```

### Leer del fichero que tiene las asignaturas
```PowerShell
$fichero=get-content asignaturas.txt
$fichero | % {
$_
}
```

### Leer del fichero que tiene las asignaturas y obtener solo la operación que hay que realizar
```PowerShell
$fichero=get-content asignaturas.txt
$fichero | % {
$_.split(',')[1]
}
```

### Leer el fichero y detectar la operación a realizar utilizando el switch
```PowerShell
$fichero = Get-Content asignaturas.txt
$fichero | % {
    $operacion = $_.split(",")
    switch($operacion[1]){
        '0'{
            echo "crear fichero"
            New-Item -Name $operacion[0] -ItemType File -Force
            break
        }
        '1'{
            echo "crear directorio"
            mkdir $operacion[0] -Force
            break
        }
    }
}
```

-------------
-------------

# Administración y aseguramiento de la información:
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.

---------------

# Linux

## A First Script
* https://www.shellscript.sh/first.html

## Ejercicios con ficheros y directorios (Bash)

```Bash
#Crear o modificar un archivo
vi nombre
```
```Bash
#Crear un directorio
mkdir
```
```Bash
#Ver el contenido de un archivo
cat
```
```Bash
#Acceder al contenido de un directorio
cd
```
```Bash
#Listar el contenido de un directorio
ls
```
```Bash
#Ver la estructura de un directorio
tree
```
```Bash
#Eliminar un archivo
rm
```
```Bash
#Eliminar un directorio
rmdir
```
```Bash
#Copiar un archivo o un directorio
cp
```
```Bash
#Mover un archivo o un directorio
mv
```
```Bash
#Renombrar un archivo o un directorio
mv
```
```Bash
#Establecer permisos en un archivo o un directorio
chmod
```
```Bash
#Comprimir y descomprimir un archivo o un directorio
gzip
```
```Bash
#Imprimir un archivo
lpr
```

## Ejercicios propuestos con ficheros y directorios (Bash)

- Crear un directorio para cada usuario
- Crear un fichero para cada usuario
- Añadir contenido a cada fichero creado para cada usuario
- Eliminar un directorio
- Renombrar un directorio
- Mover archivos de una carpeta a otra

## Ejercicios resueltos con ficheros y directorios (Bash)

1. Crear fichero que tenga tu nombre
```Bash	
 	echo Alejandro > fichero.txt
	#-------------------------
	who | awk '{print $1}' > fichero.txt
```
2. Ver el contenido de un fichero cuyo nombre esta guardado en otro fichero
```Bash
	cat `cat fichero.txt`
	#--------------------
	fich1= cat fichero
	cat $fich1
```
3. Listar contenido de un directorio y almacenarlo en un fichero
```Bash	
	ls directorio > listaDeDirectorio.txt
	cat listadeDirectorio.txt
```
4. Eliminar un fichero leyendo el nombre de este desde otro fichero
```Bash
	echo fichero1.txt > fichero2.txt

	rm `cat ficher2.txt`
	#------------------------------
	fic=cat ficher2.txt
	rm $fic
```
5. Eliminar directorio leyendo el nombre desde este desde otro fichero.	
```Bash
	echo directorio > fichero.txt
	
	mkdir `cat fichero.txt`
	
	rm -r `cat fichero.txt`
	#------------------------------
	direc=cat fichero.txt
	
	mkdir $direc
	rm -r $direc
```
6. Comprimir un directorio
```Bash
	gzip fichero
```

------------------

# Ejercicios resueltos con ficheros y directorios (PowerShell)

## Crear directorios con los meses del año
```PowerShell
foreach($mes in 1..12)
{
    mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes) -WhatIf
}
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 1)
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio) -WhatIf
}
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 2)
```PowerShell
mkdir (2020..2030) -WhatIf
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 3)
```PowerShell
foreach($anio in 1..10)
{
    (Get-Date).AddYears($anio).Year
}
```

## En cada uno de los directorios anteriores, crea un subdirectorio con los meses del año
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio)
    cd $anio
    foreach($mes in 1..12)
    {
        mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes)
    }
    cd ..
}
```

## En cada mes, crear un directorio con cada día del mes
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio)
    cd $anio
    foreach($mes in 1..12)
    {
        mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes)
        cd $mes
        1..31 | %{mkdir $_}
        cd ..
    }
    cd ..
}
```

## Trabajar con fechas
```PowerShell
$mes = (get-date).Month
$ano = (get-date).year
$dia = (get-date).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (día anterior)
```PowerShell
$mes = (get-date).AddDays(-1).Month
$ano = (get-date).AddDays(-1).Year
$dia = (get-date).AddDays(-1).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (listar varios días)
```PowerShell
-1..-7
 
foreach($dias in (-1..-7))
{
    $dias
}
 
foreach($dias in (-1..-7))
{
    (Get-Date).AddDays($dias)
}
 
foreach($dias in (-1..-7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
}
```

## Hay un proceso que falla, revisad la información sobre servicios, procesos e hilos durante una semana (creando ficheros de registro varias veces al día)
 
### Parte 1
### -Crear la carpeta para cada día y para varios momentos del día

#### Solución rara (o no), calculando el número de horas
```PowerShell
foreach($dias in (1..168))
{
    $mes = (get-date).AddHours($dias).Month
    $ano = (get-date).AddHours($dias).Year
    $dia = (get-date).AddHours($dias).Day
    $horas = (get-date).AddHours($dias).Hour
    mkdir $ano$mes$dia$horas -WhatIf
}
```
#### Solución medio buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    foreach($horas in 0..23)
    {
        mkdir $ano$mes$dia$horas -WhatIf
    }
}
```
#### Solución bastante buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
   
    foreach($horas in 0..23)
    {
        $ruta = [String]$ano+[String]$mes+[String]$dia
        $ruta
        New-Item -Name $horas -Path $ruta -ItemType Directory -WhatIf
    }
}
```
#### Solución mucha locura
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta0 = $ano+"\"+$mes+"\"+$dia
    mkdir $ruta0 -WhatIf
   
    foreach($horas in 0..23)
    {
        New-Item -Name $horas -Path $ruta0 -ItemType Directory -WhatIf
    }
}
```

### Parte 2
#### -Listar procesos
#### -Listar hilos
#### -Listar servicios

#### Solución que se ejecuta durante una semana (168 horas)
```PowerShell
foreach($veces in 168)
{
    $fecha = (Get-Date).ToString("yyyy\\MM\\dd")
    mkdir $fecha -Force
 
    $hora = (Get-Date).Hour
    New-Item -Name $hora -Path $fecha -ItemType Directory -Force
 
    (Get-Process).Name > ([String]($fecha+"\"+$hora+"\procesos.txt"))
    (Get-Service).Name > ([String]($fecha+"\"+$hora+"\servicios.txt"))
    (Get-Process).Threads > ([String]($fecha+"\"+$hora+"\hilos.txt"))
 
    Start-Sleep -Seconds 3600
}
```

#### Solución de Daniel Cebrián
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta = $ano+"\"+$mes+"\"+$dia

    mkdir $ruta -Force

    foreach($horas in 0..23)
    {   
        New-Item -Name $horas -Path $ruta -ItemType Directory -Force
        [String]$procesos = (gps).name
        [String]$ruta1= ($ruta+"\"+$horas)
        New-Item -Name procesos.txt -Path $ruta1 -ItemType File -value $procesos -Force
    }
}
```

--------
--------

# Administración y aseguramiento de la información:
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.

---------------

# Examen if y foreach
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-11-05.md#examen-de-noviembre

---------------

# Permisos en Linux
* https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-23.md
* https://github.com/jesnino/Bash/blob/master/Permisos/EjercicioPermisos.sh

|Permiso|Explicación
|---|---
|- - -	= 0|no se tiene ningún permiso
|- - x	= 1|solo permiso de ejecución
|- w -	= 2|solo permiso de escritura
|- w x	= 3|permisos de escritura y ejecución
|r - -	= 4|solo permiso de lectura
|r - x	= 5|permisos de lectura y ejecución
|r w -	= 6|permisos de lectura y escritura
|r w x	= 7|todos los permisos establecidos, lectura, escritura y ejecución

## Comandos sobre permisos
|Command|Explain
|---|---
|chmod|modify file access rights
|su|temporarily become the superuser
|sudo|temporarily become the superuser
|chown|change file ownership
|chgrp|change a file's group ownership
|umask|mask

## Ejercicios resueltos sobre permisos
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjemplosPermisosAleatorios
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjemplosPermisosAleatoriosConUGO

## Ejercicios propuestos con ficheros y directorios (Bash)

- Asignar permisos para una carpeta para cada usuario
- Asignar permisos para un fichero para cada usuario
- Asignar permisos para una carpeta para cada grupo
- Asignar permisos para un fichero para cada grupo

## Script con tareas sobre permisos (script.sh)

- Crear un directorio (directorio) y un fichero (fichero)
```Bash
    mkdir directorio
    touch fichero
```
- Asignar permisos a directorio y fichero iniciales
```Bash
    chmod 611 directorio -> chmod u=rw,go=x directorio
    chmod 611 fichero -> chmod u=rw,go=x fichero
```
- Asignar permisos a directorio y fichero de cambio
```Bash
    chmod 742 directorio
    chmod 742 fichero
```
- Cambiar el usuario dueño del fichero
```Bash
    chown root fichero
```
- Cambiar el grupo dueño del directorio
```Bash
    chgrp root directorio
```

-------------

# Ejerecicio repaso de PowerShell
## Crear un estructura de directorios con la fecha de hoy y en cada directorio meter información sobre hilos (relación con el proceso)

### Ayuda
```PowerShell

mkdir 20191029
cd 20191029

mkdir (Get-Process).Name

foreach($proceso in (Get-Process).Name)
{
    cd $proceso
    (Get-Process -Name $proceso).Threads > informacion.txt
    cd ..
}
```

### Solución
```PowerShell
mkdir (Get-Process).id -Force

(Get-Process -Id 4).Threads.id

foreach($procesos in (Get-Process).id)
{
    cd $procesos
    (Get-Process -id $procesos).Threads >> info.txt
    cd ..
}
```

## Crear dos ficheros y mostrar el nombre sin la extensión
```PowerShell
"fichero" > 123-10.txt
"fichero" > 123-11.txt
 
Get-ChildItem 123*.txt
foreach($elementos in (Get-ChildItem 123-??.txt).name)
{
    $elementos.Split("-")[1].replace(".txt","")
}
```

## Crear una carpeta por cada servicio
```PowerShell
mkdir (Get-Service).Name -WhatIf
```

## Trabajar con fechas
```PowerShell
$mes = (get-date).Month
$ano = (get-date).year
$dia = (get-date).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (día anterior)
```PowerShell
$mes = (get-date).AddDays(-1).Month
$ano = (get-date).AddDays(-1).Year
$dia = (get-date).AddDays(-1).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (listar varios días)
```PowerShell
-1..-7
 
foreach($dias in (-1..-7))
{
    $dias
}
 
foreach($dias in (-1..-7))
{
    (Get-Date).AddDays($dias)
}
 
foreach($dias in (-1..-7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
}
```

## Hay un proceso que falla, revisad la información sobre servicios, procesos e hilos durante una semana (creando ficheros de registro varias veces al día)
 
### Parte 1
### -Crear la carpeta para cada día y para varios momentos del día

#### Solución rara (o no), calculando el número de horas
```PowerShell
foreach($dias in (1..168))
{
    $mes = (get-date).AddHours($dias).Month
    $ano = (get-date).AddHours($dias).Year
    $dia = (get-date).AddHours($dias).Day
    $horas = (get-date).AddHours($dias).Hour
    mkdir $ano$mes$dia$horas -WhatIf
}
```
#### Solución medio buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    foreach($horas in 0..23)
    {
        mkdir $ano$mes$dia$horas -WhatIf
    }
}
```
#### Solución bastante buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
   
    foreach($horas in 0..23)
    {
        $ruta = [String]$ano+[String]$mes+[String]$dia
        $ruta
        New-Item -Name $horas -Path $ruta -ItemType Directory -WhatIf
    }
}
```
#### Solución mucha locura
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta0 = $ano+"\"+$mes+"\"+$dia
    mkdir $ruta0 -WhatIf
   
    foreach($horas in 0..23)
    {
        New-Item -Name $horas -Path $ruta0 -ItemType Directory -WhatIf
    }
}
```

### Parte 2
#### -Listar procesos
#### -Listar hilos
#### -Listar servicios

#### Solución que se ejecuta durante una semana (168 horas)
```PowerShell
foreach($veces in 168)
{
    $fecha = (Get-Date).ToString("yyyy\\MM\\dd")
    mkdir $fecha -Force
 
    $hora = (Get-Date).Hour
    New-Item -Name $hora -Path $fecha -ItemType Directory -Force
 
    (Get-Process).Name > ([String]($fecha+"\"+$hora+"\procesos.txt"))
    (Get-Service).Name > ([String]($fecha+"\"+$hora+"\servicios.txt"))
    (Get-Process).Threads > ([String]($fecha+"\"+$hora+"\hilos.txt"))
 
    Start-Sleep -Seconds 3600
}
```

#### Solución de Daniel Cebrián
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta = $ano+"\"+$mes+"\"+$dia

    mkdir $ruta -Force

    foreach($horas in 0..23)
    {   
        New-Item -Name $horas -Path $ruta -ItemType Directory -Force
        [String]$procesos = (gps).name
        [String]$ruta1= ($ruta+"\"+$horas)
        New-Item -Name procesos.txt -Path $ruta1 -ItemType File -value $procesos -Force
    }
}
```

-----------
-----------

# Simulacro examen liberatorio

## Almacenar toda la información que puedas mediante carpetas y ficheros sobre el servicio Audiosrv y CryptSvc (procesos, hilos) 
- Utiliza if y foreach

## Preguntar al usuario qué información quiere obtener sobre Audiosrv y CryptSvc, las opciones son:
1. Información sobre servicio
2. Información sobre procesos relacionados con los servicios
3. Información sobre hilos relacionados con los procesos de los servicios

### Ayuda
#### Menú simple
```PowerShell
$opcion = Read-Host "¿Qué información quiere obtener sobre Audiosrv y CryptSvc?"
if($opcion -eq 1)
{
    "Información sobre servicio"
}
```

### If con dos condiciones
```PowerShell
$var1 = "hola"
$var2 = "adios"

if($var1 -eq "hola" -or $var2 -eq "adios")
{
    "$var1 es hola o $var2 es adios"
}
```

---------------
---------------

# Resumen de todo lo que hemos visto

## Instalación de software libre y propietario

- Estructura de un sistema informático. Monolítica. Jerárquica. Capas o anillos (ring). Máquinas virtuales. Cliente-servidor.
  * https://github.com/jesusninoc/ClasesISO/blob/master/2019-09-17.md#n%C3%BAcleo
  ```PowerShell
  # Mostrar información sobre el núcleo
  [System.Environment]::OSVersion.Version
  wsl uname -r
  ```
  ```PowerShell
  # Mostrar información sobre el núcleo mediante una función
  function mostrarinformacion()
  {
      # Mostrar información sobre el núcleo
      [System.Environment]::OSVersion.Version
      wsl uname -r
  }
  mostrarinformacion
  ```
- Arquitectura de un sistema operativo. Sistemas por lotes (batch). Sistemas por lotes con multiprogramación. Sistemas de tiempo compartido. Sistemas distribuidos.
  * https://www.jesusninoc.com/07/03/3-gestion-del-hardware-en-powershell/#Procesador
- Funciones de un sistema operativo.
  - Controlar y gestionar el uso del hardware del ordenador: CPU, dispositivos de E/S, Memoria principal, tarjetas gráficas y el resto de periféricos.
    * https://www.jesusninoc.com/07/03/3-gestion-del-hardware-en-powershell
    ```PowerShell
    # Mostrar la carga del procesador
     Get-WmiObject win32_processor | Select-Object LoadPercentage
    ```
    ```PowerShell
    function mostrarcargaprocesador()
    {
        # Mostrar la carga del procesador
        Get-WmiObject win32_processor | Select-Object LoadPercentage
    }
    mostrarcargaprocesador
    ```
  - Administrar la ejecución de los procesos. Planificación.
    * https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/
    * https://github.com/jesusninoc/Scripts/blob/master/Ver%20si%20Apache%20est%C3%A1%20encendido.sh
    * https://github.com/jesusninoc/Scripts/blob/master/Ver%20si%20MySQL%20est%C3%A1%20encendido.sh
    * https://github.com/jesusninoc/Scripts/blob/master/Ver%20si%20Apache%20est%C3%A1%20encendido%20y%20enviar%20un%20mail.sh
    * https://github.com/jesnino/Bash/blob/master/Procesos/EjerciciosProcesos.sh
    
    ```PowerShell
    # Crear una carpeta con la fecha de hoy que contenga los procesos que se están ejecutando junto con información sobre los hilos (solución 1)

    $fecha = (Get-Date).ToString("yyyyMMdd")
    mkdir $fecha
    cd $fecha

    mkdir (Get-Process | select Name -Unique).name

    foreach($carpeta in (Get-ChildItem).Name)
    {
        $carpeta
        (Get-Process -Name $carpeta).Threads >> ($carpeta+"\informacion.txt")
    }
    ```
    ```PowerShell
    # Crear una carpeta con la fecha de hoy que contenga los procesos que se están ejecutando junto con información sobre los hilos (solución 2)

    $fecha = (Get-Date).ToString("yyyyMMdd")
    mkdir $fecha
    cd $fecha

    foreach($carpeta in (Get-Process | select Name -Unique).name)
    {
        $carpeta
        mkdir $carpeta
        (Get-Process -Name $carpeta).Threads >> ($carpeta+"\informacion.txt")
    }
    ```
    ```PowerShell
    # Crear una carpeta con la fecha de hoy que contenga los procesos que se están ejecutando junto con información sobre los hilos (solución mediante funciones)

    function infohilos ($proceso)
    {
        # Valores que necesita: proceso
        # Valores que devuelve: hilos
        (Get-Process -Name $proceso).Threads >> ($proceso+"\informacion.txt")
    }

    $fecha = (Get-Date).ToString("yyyyMMdd")
    mkdir $fecha
    cd $fecha

    foreach($proceso in (Get-Process | select Name -Unique).name)
    {
        $proceso
        mkdir $proceso -force
        infohilos $proceso
    }
    ```
    ```PowerShell
    # Crear una carpeta con la fecha de hoy que contenga los procesos que se están ejecutando junto el número de hilos (solución mediante funciones)

    function contarhilos ($proceso)
    {
        # Valores que necesita: proceso
        # Valores que devuelve: hilos
        (Get-Process -Name $proceso).Threads.Count
    }

    $fecha = (Get-Date).ToString("yyyyMMdd")
    mkdir $fecha
    cd $fecha

    foreach($proceso in (Get-Process | select Name -Unique).name)
    {
        $proceso
        mkdir $proceso -force
        contarhilos $proceso
    }
    ```
    ```PowerShell
    # Arrancar un servicio
    New-Service -Name "Tes2" -BinaryPathName '"C:\Program Files\MySQL\MySQL Server 5.1\bin\mysqld" --defaults-file="C:\Program Files\MySQL\MySQL Server 5.1\my.ini" MySQL'

    Start-Service tes2
    Stop-Service tes2
    ```
    ```Bash
    # Eliminar un proceso o un servicio
    kill -9 `pidof apache2`
    ```
      
  - Controlar el proceso de organización de la información. Creación, acceso (ubicación física) y borrado de archivos.
    * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Archivos
  - Controlar el acceso de los programas o los usuarios a los recursos del sistema.
  ```Bash
  ps -U root -u root u
  ps -eo user,comm
  ```
  - Proporcionar interfaces de usuario: en modo texto y gráficos.
  - Servicios soporte: actualizaciones de software, controladores para nuevos periféricos, etc.
    * https://www.jesusninoc.com/07/05/5-gestion-del-software-en-powershell/#Actualizaciones
    * https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/
    * https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-15.md#ver-actualizaciones
    * https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-15.md#obtener-informaci%C3%B3n-sobre-las-actualizaciones
    ```PowerShell
    # Crear carpetas para cada tipo de ProviderName y dentro de cada carpeta meter los paquetes de cada ProviderName
    
    foreach($programa in Get-Package | select ProviderName, name)
    {
        mkdir $programa.ProviderName -Force
        $programa.Name >> ($programa.ProviderName+"\informacion.txt")
    }
    ```
    ```PowerShell
    # Crear carpetas para cada tipo de ProviderName y dentro de cada carpeta meter los paquetes de cada ProviderName (mediante funciones)

    function clasificarporProviderName($programa)
    {
        $programa.Name >> ($programa.ProviderName+"\informacion.txt")
    }

    foreach($programa in Get-Package | select ProviderName, name)
    {
        mkdir $programa.ProviderName -Force
        clasificarporProviderName $programa
    }
    ```
- Tipos de sistemas operativos.
  - Monousuario o multiusuario
  - Centralizado o distribuido
  - Monotarea o multitarea
  - Uniprocesador o multiprocesador
  - Instalables y/o autoarrancables.
- Sistemas operativos libres.
- Sistemas operativos propietarios.
- Tipos de aplicaciones. Software de sistema. Software de programación. Software de aplicación.
- Licencias y tipos de licencias. Según los derechos que cada autor se reserva sobre su obra. Según su destinatario.
- Máquinas virtuales (M.V.)
  - Concepto de virtualización del hardware y características de los principales productos software libre y propietario, para el uso de máquinas virtuales.
    * https://www.jesusninoc.com/07/06/6-virtualizacion-en-powershell/ 
  - Creación y personalización de M.V.
    * https://www.jesusninoc.com/07/06/6-virtualizacion-en-powershell/#Crear_host_virtual
  - Ventajas e inconvenientes de la virtualización.
- Consideraciones previas a la instalación de sistemas operativos libres y propietarios.
  - Particionado del disco duro.
    * https://github.com/jesusninoc/ClasesISO/blob/master/2018-04-04.md
    * https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-17.md#comandos-para-trabajar-con-discos-en-linux
  - En sistemas Windows determinar la partición donde instalaremos el S.O.
  - En sistemas Linux determinar las particiones para los distintos puntos de montaje.
  - Controladores (drivers) de almacenamiento necesarios.
    * https://github.com/jesusninoc/PowerShell/blob/master/Procesos/EjerciciosProcesosAvanzado.ps1
    * https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-15.md#ver-controladores 
- Instalación de sistemas operativos.
  - Requisitos hardware, versiones y licencias.
    * https://www.jesusninoc.com/07/03/3-gestion-del-hardware-en-powershell/
    * https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-12.md
    * https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware.ps1
    * https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware2.ps1
    * https://github.com/jesusninoc/ClasesISO/blob/master/2019-11-20.md#1-realizar-un-inventario-de-tu-equipo-a-nivel-hardware-y-software-ten-en-cuenta-c%C3%B3mo-clasificar-la-informaci%C3%B3n-y-no-olvides-temas-importantes-como-por-ejemplo-controladores
  - Soporte utilizado para la instalación: CD/DVD, Pendrive, LAN.
  - Datos necesarios para la instalación: usuarios, contraseñas, nombre del equipo, direcciones IP, número de licencia, etc.
- Gestión de varios sistemas operativos en un ordenador.
  - Requisitos previos. Administración del espacio del disco. Particionado y redimensionado.
  - Problemas con el registro maestro de arranque (MBR). Elegir un gestor de arranque compatible con todos los sistemas operativos a instalar.
  - Preparar las particiones de los S.O. para permitir su arranque.
  - Analizar el orden en la instalación de los sistemas operativos.
- Gestores de arranque.
  - Código de arranque maestro (Master Boot Code).
    * https://github.com/jesusninoc/ClasesISO/blob/master/2018-10-08.md#arranque 
  - Formatos tabla de particiones. Master Boot Record (MBR) y Guid Partition Table (GPT).
  - Configuración de los gestores de arranque de los sistemas operativos libres y propietarios.
  - Reparación del gestor de arranque.
  - Sustitución del gestor de arranque estándar por otro más completo.
- Instalación/desinstalación de aplicaciones. Requisitos hardware y software, versiones y licencias.
  * https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-15.md#instalar-un-paquete-msi-junto-con-informaci%C3%B3n-sobre-la-instalaci%C3%B3n
- Actualización de sistemas operativos y aplicaciones.
  - Actualizar a una versión superior (update).
    * https://www.jesusninoc.com/07/05/5-gestion-del-software-en-powershell/#Actualizaciones
  - Cambiar a una versión inferior (downgrade).
  - Instalación de parches: de seguridad, funcionales, opcionales, etc.
  - Automatizar las actualizaciones. Configurar la fuente de las actualizaciones.
- Ficheros necesarios para el arranque de los principales sistemas operativos.
- Registros (logs) del sistema.
  - Formato de los registros: fuente/origen, prioridades (informativos, advertencias, errores, etc.)
  - Herramientas para su monitorización en sistemas libres y propietarios.
    * https://www.jesusninoc.com/07/10/10-gestion-del-rendimiento-en-powershell/#Registros_del_sistema
    ```PowerShell
    # Almacenar el número de procesos que se están ejecutando y el número de hilos de cada proceso

    $procesos = gps
    $procesos.count | Out-File log.log -Append

    foreach($proceso in $procesos)
    {
        $proceso.Name | Out-File log.log -Append
        $proceso.threads.Count | Out-File log.log -Append
    }
    ```
    ```PowerShell
    # Almacenar el número de procesos que se están ejecutando y el número de hilos de cada proceso (mediante funciones, cutre)

    function guardarnombre()
    {
        $proceso.Name | Out-File log.log -Append
    }
    function guardarhilos()
    {
        $proceso.threads.Count | Out-File log.log -Append
    }

    $procesos = gps
    $procesos.count | Out-File log.log -Append

    foreach($proceso in $procesos)
    {
        guardarnombre
        guardarhilos
    }
    ```
    ```PowerShell
    # Almacenar el número de procesos que se están ejecutando y el número de hilos de cada proceso (mediante funciones)

    function guardarnombre($proceso)
    {
        $proceso.Name | Out-File log.log -Append
    }
    function guardarhilos($proceso)
    {
        $proceso.threads.Count | Out-File log.log -Append
    }

    $procesos = gps
    $procesos.count | Out-File log.log -Append

    foreach($proceso in $procesos)
    {
        guardarnombre $proceso
        guardarhilos $proceso
    }
    ```
  - Gestión: Aplicar filtros, asociar tareas en respuesta a ciertos eventos, etc.
- Actualización y mantenimiento de controladores de dispositivos.
  - Automatizar la actualización de controladores.
  - Volver a una versión anterior de un controlador.
  - Actualización manual de los controladores.

## Administración y aseguramiento de la información
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
    * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#La_ruta
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.
  * https://github.com/jesusninoc/Bash/blob/master/Ficheros/EjerciciosFicherosBuscar.sh
- Identificación del software instalado mediante comandos y herramientas gráficas.
  * https://www.jesusninoc.com/07/05/5-gestion-del-software-en-powershell/
- Gestión de la información del sistema. Rendimiento. Estadísticas.
  * https://www.jesusninoc.com/07/10/10-gestion-del-rendimiento-en-powershell/#Rendimiento
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
  * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Discos
- En sistemas Windows montar un volumen en una o más carpetas.
  * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Montar_un_disco_virtual
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
  * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Discos
- Permisos locales de acceso a ficheros y directorios.
  * https://github.com/jesusninoc/ClasesISO/blob/master/2019-11-05.md#permisos-en-linux
  * https://github.com/jesusninoc/ClasesISO/blob/master/2019-11-07.md#permisos-en-linux
  * https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Permisos-2
  * https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-26.md
  * https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-27.md
  * https://www.jesusninoc.com/03/30/eliminar-permisos-explicitos/

---------
---------

# Administración y aseguramiento de la información:
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.

---------------

# Soluciones examen simulacro (y ver funciones)
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-11-19.md#simulacro-examen-liberatorio

# Soluciones con funciones

## Información sobre servicios (pero no se obtiene información sobre procesos)
```PowerShell
(Get-Service -Name Audiosrv,CryptSvc) | select *

## Información sobre servicios (buscar dos nombres de servicios, atentos al .name)
```PowerShell
foreach ($servicio in Get-WmiObject -Class win32_service)
{
    if($servicio.Name -eq "Audiosrv")
    {
        $servicio
    }
    if($servicio.Name -eq "CryptSvc")
    {
        $servicio
    }
}
```

## Información sobre los procesos de los servicios
```PowerShell
foreach ($servicio in Get-WmiObject -Class win32_service)
{
    if($servicio.Name -eq "Audiosrv")
    {
        Get-Process -id $servicio.ProcessId
    }
    if($servicio.Name -eq "CryptSvc")
    {
        Get-Process -id $servicio.ProcessId
    }
}
```

## Información sobre los hilos de los procesos de los servicios
```PowerShell
foreach ($servicio in Get-WmiObject -Class win32_service)
{
    if($servicio.Name -eq "Audiosrv")
    {
        (Get-Process -id $servicio.ProcessId).Threads.id
        "----------------------------------"
    }
    if($servicio.Name -eq "CryptSvc")
    {
        (Get-Process -id $servicio.ProcessId).Threads.id
    }
}
```

## Juntar los dos if para obtener información sobre los servicios
```PowerShell
foreach ($servicio in Get-WmiObject -Class win32_service)
{
    if($servicio.Name -eq "Audiosrv" -or $servicio.Name -eq "CryptSvc")
    {
        $servicio
    }
}
```
 
## Preguntar al usuario mediante una función por la operación que quiera realizar:
- 1. Información sobre servicio
- 2. Información sobre procesos relacionados con los servicios
- 3. Información sobre hilos relacionados con los procesos de los servicios
```PowerShell
function comprobar()
{
    $opcion = Read-Host "¿Qué información quiere obtener sobre Audiosrv y CryptSvc?"
    switch($opcion)
    {
        "1"{
            foreach ($servicio in Get-WmiObject -Class win32_service)
            {
                if($servicio.Name -eq "Audiosrv" -or $servicio.Name -eq "CryptSvc")
                {
                    $servicio
                }
            }
        }
        "2"{
            foreach ($servicio in Get-WmiObject -Class win32_service)
            {
                if($servicio.Name -eq "Audiosrv" -or $servicio.Name -eq "CryptSvc")
                {
                    Get-Process -id $servicio.ProcessId
                }
            }
        }
        "3"{
            foreach ($servicio in Get-WmiObject -Class win32_service)
            {
                if($servicio.Name -eq "Audiosrv" -or $servicio.Name -eq "CryptSvc")
                {
                    (Get-Process -id $servicio.ProcessId).Threads.id
                }
            }
        }
    }
}

for(1)
{
    comprobar
}
```

## Función que se dedica a comprobar operaciones
```PowerShell
function comprobar($numero)
{
    foreach ($servicio in Get-WmiObject -Class win32_service)
    {
        if($servicio.Name -eq "Audiosrv" -or $servicio.Name -eq "CryptSvc")
        {
            switch($numero)
            {
                "1"{$servicio}
                "2"{Get-Process -id $servicio.ProcessId}
                "3"{(Get-Process -id $servicio.ProcessId).Threads.id}
            }
        }
    }
}
```

## Probar aleatoriamente operaciones
```PowerShell
for(1)
{
    comprobar (Get-Random(1..3))
    Start-Sleep -Seconds 5
}
```

## Probar operaciones leyendo de un fichero
```PowerShell
foreach ($operacionautomatica in gc .\operaciones.txt)
{
     comprobar $operacionautomatica
}
```

## Crear una función en la que pasas una fecha, te crea un directorio (año/mes/día) y también le pasas la palabra procesos, hilos o servicios y te crea ese contenido dentro de la carpeta que acabas de crear
```PowerShell
function pasarfecha($fecha,$palabra)
{
    mkdir $fecha.ToString("yyyyMMdd")
    cd $fecha.ToString("yyyyMMdd")
    switch($palabra)
    {
        "procesos"{Get-Process | Out-File procesos.txt}
        "servicios"{Get-Service | Out-File servicios.txt}
        "hilo"{(Get-Process).Threads.id | Out-File servicios.txt}
    }
    cd ..
}

pasarfecha (Get-Date) procesos
```

-------------

# Funciones en PowerShell
* https://www.jesusninoc.com/07/02/2-programacion-en-powershell/#Funciones
* https://www.jesusninoc.com/10/14/funciones-con-parametros-y-sin-parametros/

## Ejemplos sobre funciones

### Mediante una función mostrar un mensaje para cada usuario y pedirle un valor
```PowerShell
function pedirymostrar($i)
{
    $valor = Read-Host ("Introduzca valor" + "usuario" + $i)
    Write-Host ("El valor es " + $valor)
}

foreach($i in 1..10)
{
    pedirymostrar $i
}
```

### Mediante una función crear una carpeta para cada proceso que se está ejecutando
```PowerShell
# mkdir (ps).Name -WhatIf

function crearcarpeta($procesos)
{
    mkdir $procesos -WhatIf
}

crearcarpeta (ps).Name
```

### Crear una función que sume dos número que pedimos al usuario
```PowerShell
function suma([Int]$valor1,[Int]$valor2)
{
    ($valor1)+($valor2)
}

$valor1 = Read-Host "Introduzca número 1"
$valor2 = Read-Host "Introduzca número 2"
suma $valor1 $valor2
```

## Ejercicios sobre funciones: mediante la utilización de funciones en PowerShell resolver las siguientes situaciones:
- Mostrar todos los procesos.
- Mostrar los X primeros procesos.
- Mostrar los X últimos procesos.
- Ordenar todos los procesos por CPU de forma descendente.
- Mostrar los X procesos cuyo consumo (el parámetro que quieras utilizar) sea mayor que el valor que quieras monitorizar.
- Agrupar los procesos y muestra los que sean XXXXX.
- Abrir una página web las veces que quiera el usuario.
- Realizar un login.

### Función para mostrar todos los procesos
```PowerShell
function Procesos
{
Get-Process
}
Procesos
```

### Función para mostrar los X primeros procesos
```PowerShell
function ProcesosPrimeros($numero)
{
Get-Process | Select-Object -First $numero
}
ProcesosPrimeros 5
```

### Función para mostrar los X primeros procesos utilizando Mandatory
```PowerShell
function ProcesosUltimosM
{
param
(
[Parameter(Mandatory=$true)]
$numero
)
Get-Process | Select-Object -Last $numero
}
ProcesosUltimosM 5
```

### Función para mostrar los X últimos procesos
```PowerShell
function ProcesosUltimos($numero)
{
Get-Process | Select-Object -Last $numero
}
ProcesosUltimos 5
```

### Función para ordenar todos los procesos por CPU de forma descendente
```PowerShell
function ProcesosCPU
{
Get-Process | Sort-Object CPU -Descending
}
ProcesosCPU
```

### Función para mostrar los X procesos cuyo consumo (el parámetro que quieras utilizar) sea mayor que el valor que quieras monitorizar
```PowerShell
function ProcesosConsumo([String]$parametro,[Int]$valor,[Int]$numerovalores)
{
$parametro
$valor
$numerovalores
Get-Process | Where-Object $parametro -GT $valor | Select-Object -First $numerovalores
}
ProcesosConsumo CPU 30 5
```

### Función para agrupa los procesos y muestra los que sean XXXXX
```PowerShell
function ProcesoConcreto($nombreproceso)
{
Get-Process -Name $nombreproceso | Group-Object
}
ProcesoConcreto svchost
```

### Abrir una página web las veces que quiera el usuario
```PowerShell
function abrirweb ($numero,$url)
{
    1..$numero | %{
        start $url
        [System.Console]::Beep(261,500)
    }
}

abrirweb 3 http://www.jesusninoc.com
```

### Realizar un login mediante una función
```PowerShell
#Login de user y pass
#El user y pass correcto se escriben en el bloque BEGIN
#Ejecutar la función: login0
login0 -User jaime -Pass hola

function login0
{
  param([Parameter(Mandatory=$true, ValueFromPipeline=$true)][String[]][AllowEmptyString()]$User,$Pass)

  begin
  {
    Write-Host "Principio de login"
    $usercorrecto="user"
    $passcorrecto="pass"
  }

  process
  {
   if($User -eq $usercorrecto -and $Pass -eq $passcorrecto)
    {
        $ok=1
    }
    else
    {
        $ok=0
    }
  }
  end
  {
   if($ok)
    {
        Write-Host "User correcto"
    }
    else
    {
        Write-Host "User no correcto"
        $User,$Pass | Out-File log.txt -Append
    }
    Write-Host "Fin de login"
  }
}
```

---------------

# Instalar un Windows Server
- Volumen
- RAID

---------------

# Permisos en Linux
* https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-23.md
* https://github.com/jesnino/Bash/blob/master/Permisos/EjercicioPermisos.sh

|Permiso|Explicación
|---|---
|- - -	= 0|no se tiene ningún permiso
|- - x	= 1|solo permiso de ejecución
|- w -	= 2|solo permiso de escritura
|- w x	= 3|permisos de escritura y ejecución
|r - -	= 4|solo permiso de lectura
|r - x	= 5|permisos de lectura y ejecución
|r w -	= 6|permisos de lectura y escritura
|r w x	= 7|todos los permisos establecidos, lectura, escritura y ejecución

## Comandos sobre permisos
|Command|Explain
|---|---
|chmod|modify file access rights
|su|temporarily become the superuser
|sudo|temporarily become the superuser
|chown|change file ownership
|chgrp|change a file's group ownership
|umask|mask

## Ejercicios resueltos sobre permisos
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjemplosPermisosAleatorios
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjemplosPermisosAleatoriosConUGO

## Ejercicios propuestos con ficheros y directorios (Bash)

- Asignar permisos para una carpeta para cada usuario
- Asignar permisos para un fichero para cada usuario
- Asignar permisos para una carpeta para cada grupo
- Asignar permisos para un fichero para cada grupo

## Script con tareas sobre permisos (script.sh)

- Crear un directorio (directorio) y un fichero (fichero)
```Bash
    mkdir directorio
    touch fichero
```
- Asignar permisos a directorio y fichero iniciales
```Bash
    chmod 611 directorio -> chmod u=rw,go=x directorio
    chmod 611 fichero -> chmod u=rw,go=x fichero
```
- Asignar permisos a directorio y fichero de cambio
```Bash
    chmod 742 directorio
    chmod 742 fichero
```
- Cambiar el usuario dueño del fichero
```Bash
    chown root fichero
```
- Cambiar el grupo dueño del directorio
```Bash
    chgrp root directorio
```

---------------

# Ejercicio PowerShell

## Ejercicio con if UN NÚMERO ES PAR O IMPAR POWERSHELL

### Un número es par?, si el resto es 0. La operación del resto es %
```PowerShell
$numero=5
$numero%2
```

### Comprobar si un número es par
```PowerShell
$numero=5
if($numero%2 -eq 0)
{
"Número par"
}
else
{
"Número impar"
}
```

### Mover a una carpeta los ficheros pares y borrar los ficheros impares
```PowwerShell
-2..-8 | % {ni ((Get-Date).AddDays($_).ToString("yyyyMMdd")+".txt")}
```

## Eliminar el contenido de las carpetas impares de un servidor web
```PowerShell
# Crear un fichero dentro de todos los directorios
-2..-8 | % {mkdir (Get-Date).AddDays($_).ToString("yyyyMM-dd")}
ni -Path (ls).name -Name fichero -ItemType File

(ls | select name).name | %{
    $resultado = $_.split("-")[1] % 2
    if ($resultado -eq 1)
    {
        cd $_
        rm * -WhatIf
    }
    else
    {

    }
}
```

# Ejercicio Bash

## Eliminar el contenido de las carpetas impares de un servidor web
```Bash
echo "hola" > 201811-7
echo "hola" > 201811-8
echo "hola" > 201811-9

for i in $( ls *-? ); do
    echo "---------"
    resultado=`echo $i | cut -d "-" -f2`
    let result=resultado%2
    echo $result
    if [ $result -eq 1 ]; then
        echo "mover"
    fi
done
```

--------------------

# Linux

## Compressing files
* https://www.cyberciti.biz/howto/question/general/compress-file-unix-linux-cheat-sheet.php

## Sumar en Linux
* https://uniwebsidad.com/foro/pregunta/300/como-se-pueden-sumar-dos-numeros-en-un-script-de-bash/

## Crear calendario en Linux
* https://www.youtube.com/watch?v=aDCfL9Pk3TQ&feature=youtu.be
* https://github.com/jesnino/Bash/blob/master/Ficheros/EjercicioCalendario.sh

## Ejemplos en Bash (con repaso sobre comandos)

### Crea  directorios con los años desde 2020 hasta 2030
```Bash
mkdir {2020..2030}
```

### En cada uno de los directorios, crea un subdirectorio con los meses del año
```Bash
mkdir -p {2020..2030}/{Enero,Febrero,Marzo,Abril,Mayo,Junio,Julio,Agosto,Septiembre,Octubre,Noviembre,Diciembre}
```

### En cada mes, crear un directorio con cada día de la semana
```Bash
mkdir -p {2020..2030}/{Enero,Febrero,Marzo,Abril,Mayo,Junio,Julio,Agosto,Septiembre,Octubre,Noviembre,Diciembre}/{Lunes, Martes,Miercoles,Jueves,Viernes,Sabado,Domingo}
```

### Borrar todos los directorios Julio y Agosto de todos los años
```Bash
rm -r {2020..2030}/{Julio,Agosto}
```

### Crear un alias del comando "rm" que se llame borrar y que permita borrar el directorio Ejercicio1 (con su contenido)
```Bash
alias borrar='rm -r -f ejercicio1'
```

----------
----------

# Administración y aseguramiento de la información:
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.

---------------

# ¿Server instalado?

---------------

# Repaso
## Eliminar el contenido de las carpetas impares de un servidor web
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-11-05.md#eliminar-el-contenido-de-las-carpetas-impares-de-un-servidor-web-1

## Estamos viendo sistema de archivos
* https://github.com/jesnino/PowerShell/blob/master/Ficheros/EjemplosLeerOperacionesTareasBasicasII.ps1

## TAREAS BÁSICAS II (SISTEMA DE ARCHIVOS)
* https://www.jesusninoc.com/2017/07/04/4-gestion-del-sistema-de-archivos-en-powershell/

|Tarea|Cmdlet
|---|---
|Crear o modificar un archivo|New-item
|Crear un directorio|New-item
|Ver el contenido de un archivo|Get-Content
|Acceder al contenido de un directorio|Set-Location
|Listar el contenido de un directorio|Get-Childitem
|Eliminar un archivo|Remove-Item
|Eliminar un directorio|Remove-Item
|Copiar un archivo o un directorio|Copy-Item
|Mover un archivo o un directorio|Move-Item
|Renombrar un archivo o un directorio|Rename-Item
|Imprimir un archivo|Out-Printer

## Fechas
https://www.jesusninoc.com/07/02/2-programacion-en-powershell/#Fechas

## Tienen atributos que se pueden listar (show hidden files)
https://www.jesusninoc.com/2014/11/23/show-hidden-files/

## Creación de directorios
* https://github.com/jesnino/PowerShell/blob/master/Ficheros/SolucionEjerciosFicherosProcesos.ps1
* https://www.youtube.com/watch?v=CibNbK9sp8A&list=PL89qBrmFzAa34fM6OEMLV6ybDk3Y34qud&index=3

## If
* https://www.jesusninoc.com/2016/08/05/sentencia-condicional-if/
* https://www.jesusninoc.com/2015/04/26/sentencia-condicional-if-else/
* https://www.jesusninoc.com/2016/08/07/sentencia-condicional-if-elseif-else/

## BUCLE EN POWERSHELL
* https://www.jesusninoc.com/2017/10/08/listar-todos-los-caracteres-ascii-en-powershell/
* https://www.jesusninoc.com/2017/10/05/listar-todos-los-caracteres-ascii-en-bash/

---------------

# Ejercicios

## Repaso eliminar ficheros impares
```PowerShell
"hola" | out-file 2020-11-26.txt
"hola" | out-file 2020-11-25.txt

foreach($nombre in Get-ChildItem)
{
    if($nombre.Name.Split("-")[2].replace(".txt","") % 2 -eq 1)
    {
        Remove-Item $nombre -WhatIf
    }
}
```

## Repaso elminar ficheros impares (con alias de foreach: %)
```PowerShell
Get-ChildItem | %{
    if($_.Name.Split("-")[2].replace(".txt","") % 2 -eq 1)
    {
        Remove-Item $_ -WhatIf
    }
} 
```

## Crear para varios días de la semana (desde lunes pasado hasta hoy jueves) una estructura de directorios con los procesos que se están ejecutando en el sistema
```PowerShell
-3..0 | %{
    mkdir (Get-Date).AddDays($_).ToString("yyyyMMdd")
    cd (Get-Date).AddDays($_).ToString("yyyyMMdd")
    mkdir (Get-Process).Name
    cd ..
}
```

## Preguntar al usuario por la operación que quiere realizar y el nombre del fichero que sobre el que quiere realizar las siguientes operaciones que tenemos que programar son:
## - comprimir un archivo
## - descomprimir un archivo
```PowerShell
$operacion = Read-Host "Introduzca operación"
if ($operacion -eq "comprimir")
{
    $ficheroparacomprimir = Read-Host "Introduzca fichero para comprimir"
    Compress-Archive $ficheroparacomprimir -DestinationPath $ficheroparacomprimir.Replace(".txt",".zip")
}
elseif ($operacion -eq "descomprimir")
{
    $ficheroparadescomprimir = Read-Host "Introduzca fichero para descomprimir"
    Expand-Archive $ficheroparadescomprimir
}
```


## Obtener el hash de los programas que se están ejecutando en el sistema
## 1. Obtener la ruta de los programas que se están ejecutando
## 2. Hacer el hash a esos programas
```PowerShell
foreach($ruta in (Get-Process))
{
    $ruta.name
    Get-FileHash $ruta.Path
}
```

## Realizar tareas leyendo de un fichero
```PowerShell
#Añadir operaciones al fichero
"fecha" | Out-File operaciones.txt -Append
"hilos" | Out-File operaciones.txt -Append
"crear" | Out-File operaciones.txt -Append
"imprimir" | Out-File operaciones.txt -Append
"comprimir" | Out-File operaciones.txt -Append

gc .\operaciones.txt

foreach($operaciones in gc .\operaciones.txt)
{
    switch($operaciones)
    {
        "fecha"{get-date}
        "hilos"{Get-Process | select Threads}
        "crear"{New-Item -Name elque -ItemType File}
        "imprimir"{echo "hola" | Out-Printer "Microsoft Print to PDF"}
        "comprimir"{Compress-Archive -LiteralPath .\123-11.txt –CompressionLevel Optimal -DestinationPath 123.zip}
    }
}
```

---------------

# Permisos en PowerShell
* https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Permisos-2
* https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-26.md
* https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-27.md
* https://www.jesusninoc.com/03/30/eliminar-permisos-explicitos/

---------------

# Permisos en Linux
## Permisos especiales en Linux
http://rm-rf.es/permisos-especiales-setuid-setgid-sticky-bit/

|Permiso|Explicación
|---|---
|- - - - - - - - -	= 0|Predeterminado, sin permisos especiales. No se requiere indicar.
|- - - - - - - - t	= 1|Bit de persistencia, sticky bit
|- - - - - s - - -	= 2|Bit sgid de grupo
|- - - - - s - - t	= 3|Bit sgid y sticky
|- - s - - - - - -	= 4|Bit suid
|- - s - - - - - t	= 5|Bit suid y sticky
|- - s - - s - - -	= 6|Bit suid y sgid
|- - s - - s - - t	= 7|Bit suid, sgid y sticky

- sticky: se utiliza para permitir que cualquiera pueda escribir y modificar sobre un archivo o directorio, pero que solo su propietario o root pueda eliminarlo. 
- suid: el bit SUID activo en un archivo significa que el que lo ejecute va a tener los mismos permisos que el que creó el archivo.
- sgid: el SGID es lo mismo que en el SUID, pero a nivel de grupo. Es decir, todo archivo que tenga activo el SGID, al ser ejecutado, tendrá los privilegios del grupo al que pertenece.

## Permisos en Linux (EJERCICOS AVANZADOS SOBRE PERMISOS)

### Permisos en Linux avanzados
* https://github.com/jesnino/Bash/blob/master/Permisos/EjercicioPermisos.sh

### Asignar permisos mediante llamada a sistema chmod en C
* https://www.jesusninoc.com/2014/12/01/chmod-system-call-example/

--------------
--------------

# Administración y aseguramiento de la información:
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.

---------------

# Discos
* https://github.com/jesusninoc/ClasesISO/blob/master/2018-04-04.md

---------------

# Clase especial
## ESCANEAR FRECUENCIAS Y CLASIFICAR LAS SEÑALES ENCONTRADAS
* https://www.jesusninoc.com/01/10/escanear-frecuencias-y-clasificar-las-senales-encontradas/
## DETECTAR MICRÓFONO ESPÍA CON CNN-RTLSDR (DEEP LEARNING SIGNAL CLASSIFICATION USING RTL-SDR DONGLE)
* https://www.jesusninoc.com/01/23/detectar-microfono-espia-con-cnn-rtlsdr-deep-learning-signal-classification-using-rtl-sdr-dongle/

---------------------

# Clase especial
## Instalar Icecast is free server software for streaming multimedia
```Bash
sudo apt-get install icecast2 darkice
```
## Descargar un mp4 y un mp3 en la carpeta /usr/share/icecast2/web
```Bash
wget https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3
```
## Reproducir ficheros desde el móvil
http://192.168.1.162:8000/sound.mp3
## Número de hilos que ejecuta Icecast
https://github.com/jesnino/Bash/blob/master/Procesos/EjerciciosHilos.sh

----------------------
----------------------

# Multimedia
## Leer palabras mediante la voz del Sistema Operativo
https://www.jesusninoc.com/2016/12/15/leer-palabras-mediante-la-voz-del-sistema-operativo/

## Leer palabras de un fichero y almacenar cada palabra en un fichero de audio mediante la voz del Sistema Operativo
https://www.jesusninoc.com/2016/12/24/leer-palabras-de-un-fichero-y-almacenar-cada-palabra-en-un-fichero-de-audio-mediante-la-voz-del-sistema-operativo/

## Convertir ficheros de audio a texto
https://www.jesusninoc.com/2016/12/25/convertir-ficheros-de-audio-a-texto/

## Convertir la entrada de micrófono a texto
https://www.jesusninoc.com/2016/12/26/convertir-la-entrada-de-microfono-a-texto/

--------------------

# Radio
## Ejercicios sobre señales de radio

[![Enviar señales de radio desde Raspberry Pi mediante una conexión SSH desde PowerShell
](https://img.youtube.com/vi/8kglbrLWHrY/0.jpg)](https://www.youtube.com/watch?v=8kglbrLWHrY)

## Enlaces importantes:
* Software-Defined Radio for Engineers https://news.ycombinator.com/item?id=17399554
* https://www.youtube.com/watch?v=8kglbrLWHrY
* https://github.com/markondej/fm_transmitter
* https://www.jesusninoc.com/2016/12/07/ejercicios-de-powershell-dividir-el-contenido-de-una-frase-en-palabras-y-guardar-cada-palabra-en-un-fichero/
* https://www.jesusninoc.com/2016/12/24/leer-palabras-de-un-fichero-y-almacenar-cada-palabra-en-un-fichero-de-audio-mediante-la-voz-del-sistema-operativo/
* https://www.jesusninoc.com/2017/11/02/subir-un-fichero-por-ssh-a-un-servidor-linux-desde-powershell-en-windows/
* https://www.jesusninoc.com/2017/09/26/ejecutar-un-script-de-powershell-en-linux-realizando-una-conexion-ssh-desde-powershell-en-windows/
* https://www.jesusninoc.com/2017/10/14/ejecutar-airodump-ng-en-linux-realizando-una-conexion-ssh-desde-powershell-en-windows/
* https://github.com/jesnino/Bash/blob/master/Ficheros/EjemplosDescomprimir.sh

## Crear un audio que vamos a mandar mediante señales de radio

```PowerShell
#Convertir una frase en audio con la voz del sistema operativo desde PowerShell

Add-Type -AssemblyName System.Speech
$synthesizer = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer
$synthesizer.SetOutputToWaveFile("saludo.wav")
$synthesizer.Speak("Hola amigo Pedro")
$synthesizer.SetOutputToDefaultAudioDevice()
Get-ChildItem .\saludo.wav
```

## Subir el audio a Raspberry Pi realizando una conexión SCP
```PowerShell
#Iniciar una sesión SCP
#Para iniciar sesión SSH es necesario indicar la dirección IP del equipo al que nos vamos a conectar y también hay que introducir los credenciales (usuario y contraseña).

$Pass = ConvertTo-SecureString -String "raspberry" -AsPlainText -Force
$Credential = New-Object -TypeName "System.Management.Automation.PSCredential" -ArgumentList "pi", $Pass

#Para configurar Set-SCPFile
#Indicar el fichero que vamos a subir -LocalFile
#Indicar el equipo al que nos vamos a conectar -ComputerName
#Indicar la ruta en la que vamos a subir el audio -RemotePath
#Forzar la conexión para evitar fallo "Key exchange negotiation failed."
#Indicar los credenciales que hemos creado anteriormente

Set-SCPFile -LocalFile .\saludo.wav -ComputerName 192.168.1.161 -RemotePath ./fmm/fm_transmitter-master -Force -Credential $Credential
```

## Enviar mediante señales de radio el fichero que hemos subido
```PowerShell
#Ejecutar fm_transmitter (use Raspberry Pi as FM transmitter)

#Iniciar una sesión SSH
#Para iniciar sesión SSH es necesario indicar la dirección IP del equipo al que nos vamos a conectar y también hay que introducir los credenciales (usuario y contraseña).

$sUser = "pi"
$Pass = ConvertTo-SecureString -String "raspberry" -AsPlainText -Force
$Credential = New-Object -TypeName "System.Management.Automation.PSCredential" -ArgumentList $sUser, $Pass
$oSessionSSH = New-SSHSession -ComputerName 192.168.1.161 -Force -Credential $Credential

#Crear canal de comunicación entre PowerShell y Linux (Raspberry Pi)
#Convertirse en sudo para ejecutar fm_transmitter

$stream = $oSessionSSH.Session.CreateShellStream("PS-SSH", 0, 0, 0, 0, 1000)
Invoke-SSHStreamExpectSecureAction -ShellStream $stream -Command "sudo su -" -ExpectString "[sudo] password for $($sUser):" -SecureAction $Pass

#Transmitir por radio en la frecuencia 90 MHz el saludo creado anteriormente
$stream.WriteLine("/home/pi/fmm/fm_transmitter-master/fm_transmitter -f 90 /home/pi/fmm/fm_transmitter-master/saludo.wav")

#Verificar que llega bien la señal desde SDR o desde una radio FM en la frecuencia 90 MHz
```

--------------------

# Realizar una comunicación enviando preguntas y respondiendo de forma automática

## Teniendo en cuenta la idea de comunicar dos ordenadores mediante la voz del sistema operativo
https://www.jesusninoc.com/2016/01/10/comunicar-dos-ordenadores-mediante-la-voz-del-sistema-operativo/

## ENVIAR PREGUNTAS
```PowerShell
#Leer el texto contenido dentro de un fichero mediante la voz del Sistema Operativo
Add-Type -AssemblyName System.Speech

#Añadir textos para que se lean
"¿Qué tal?" | Out-File conversacion.txt
"¿Cuántos años tienes?" | Out-File conversacion.txt -Append
"¿Tienes novia?" | Out-File conversacion.txt -Append

#Leer los textos mediante la voz del Sistema Operativo
gc conversacion.txt | %{
$_
(New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer).Speak($_)
Start-Sleep -Seconds 3
}
```

## RECONOCIMIENTO Y RESPUESTA
```PowerShell
#Crear objeto para reconocimiento
Add-Type -AssemblyName System.Speech
$rec = New-Object 'System.Speech.Recognition.SpeechRecognitionEngine'
$rec.LoadGrammar((New-Object 'System.Speech.Recognition.DictationGrammar'))
$rec.SetInputToDefaultAudioDevice()

#Añadir posibles respuestas
"tal|Bien y tú?" | Out-File frases.txt
"años|40" | Out-File frases.txt -Append
"novia|Sí" | Out-File frases.txt -Append
"novio|Sí" | Out-File frases.txt -Append

#Crear un ArrayList con las respuestas
[System.Collections.ArrayList]$arraylist = New-Object System.Collections.ArrayList
ForEach ($elemento in (gc .\frases.txt).split("|")){[void]$arraylist.Add($elemento)}

#Función para comprobar si el mensaje que llega está entre las posibles respuestas
#La función responde mediante la voz del Sistema Operativo
function comprobar($frase){
    [System.Collections.ArrayList]$arraylist2 = New-Object System.Collections.ArrayList
    ForEach ($elemento in $frase.split(" ")){[void]$arraylist2.Add($elemento)}

    $arraylist2 | %{
        if($arraylist.IndexOf($_) -ne -1){
            (New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer).Speak($arraylist[($arraylist.IndexOf($_))+1])
        }
    }
}

#Comenzar a reconocer los audios que vayan llegando y comprobar qué mensajes llegan
do{
$mensaje=$rec.Recognize().Text
$mensaje
comprobar $mensaje
}while(1)
```

--------------------

# Motor de síntesis de voz en PowerShell

## Realizar: 
- Pronunciar un texto mediante el motor de síntesis de voz en PowerShell
- Pronunciar un texto cambiando la voz del motor de síntesis de voz en PowerShell
- Guardar en un fichero de audio un texto pronunciado mediante el motor de síntesis de voz en PowerShell

## Vídeo en Youtube
https://www.youtube.com/watch?v=eFqCh7JR5rc&list=UUNQh1Ef6VUqRzejB5lrTc0Q&index=16

[![Utilizar el motor de síntesis de voz en Powershell para leer cualquier texto
](https://img.youtube.com/vi/eFqCh7JR5rc/0.jpg)](https://www.youtube.com/watch?v=eFqCh7JR5rc)

## Pronunciar un texto mediante el motor de síntesis de voz en PowerShell
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz
$speaker = [System.Speech.Synthesis.SpeechSynthesizer]::new()

#Obtener información sobre la voz actual del motor de síntesis de voz
$speaker.Voice

#Pronunciar el texto
$speaker.Speak("Hola, hola. ¿Qué tal estás?. ¿Qué edad tienes?.")
```

## Pronunciar un texto cambiando la voz del motor de síntesis de voz en PowerShell
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz
$speaker = [System.Speech.Synthesis.SpeechSynthesizer]::new()

#Cambiar la voz actual del motor de síntesis de voz
$speaker.SelectVoice("Microsoft Helena Desktop")

#Pronunciar el texto
$speaker.Speak("Hola, hola. ¿Qué tal estás?. ¿Qué edad tienes?.")
```

## Guardar en un fichero de audio un texto pronunciado mediante el motor de síntesis de voz en PowerShell
```PowerShell
#Cargar el espacio de nombres System.Speech que contiene los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz
$speaker = [System.Speech.Synthesis.SpeechSynthesizer]::new()

#Configurar el motor de síntesis de voz para guardar en un fichero de audio
$speaker.SetOutputToWaveFile("saludos.wav")

#Pronunciar el texto
$speaker.Speak("Hola, hola. ¿Qué tal estás?. ¿Qué edad tienes?.")

#Configurar el motor de síntesis de voz para enviar el resultado en el dispositivo de audio predeterminado
$speaker.SetOutputToDefaultAudioDevice()

.\saludos.wav
```

--------------------

# Reconocimiento mediante el motor de síntesis

## Realizar: 
1. Reconocer una palabra con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para el dictado de texto sin formato
2. Reconocer una palabra contenida en un fichero de audio con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para texto sin formato
3. Reconocer varias palabras con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para el dictado de texto sin formato
4. Reconocer varias palabras contenidas en un fichero de audio con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para texto sin formato
5. Reconocer varias palabras contenidas en un fichero de audio con el motor de síntesis de voz en PowerShell creando las restricciones de una gramática de reconocimiento de voz

## Vídeo en Youtube
https://www.youtube.com/watch?v=z2PHuFKBjfU

[![Utilizar el motor de síntesis de voz en Powershell para analizar audios con voz](https://img.youtube.com/vi/z2PHuFKBjfU/0.jpg)](https://www.youtube.com/watch?v=z2PHuFKBjfU)

## 1. Reconocer una palabra con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para el dictado de texto sin formato
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz que permite a PowerShell escuchar voz
$speechRecogEng = [System.Speech.Recognition.SpeechRecognitionEngine]::new()

#Representar una gramática de reconocimiento de voz utilizada para el dictado de texto sin formato
$speechRecogEng.LoadGrammar([System.Speech.Recognition.DictationGrammar]::new())

#Configurar el motor de síntesis de voz para recibir la entrada desde el dispositivo de audio predeterminado
$speechRecogEng.SetInputToDefaultAudioDevice()

#Inicia una operación de reconocimiento de voz sincrónico
$speechRecogEng.Recognize()
```

## 2. Reconocer una palabra contenida en un fichero de audio con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para texto sin formato
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz que permite a PowerShell escuchar voz
$speechRecogEng = [System.Speech.Recognition.SpeechRecognitionEngine]::new()

#Representar una gramática de reconocimiento de voz utilizada para el dictado de texto sin formato
$speechRecogEng.LoadGrammar([System.Speech.Recognition.DictationGrammar]::new())

#Configurar el motor de síntesis de voz para recibir la entrada desde un archivo de formato de sonido (.wav)
$speechRecogEng.SetInputToWaveFile(".\holas.wav")

#Inicia una operación de reconocimiento de voz sincrónico
$speechRecogEng.Recognize()
```

## 3. Reconocer varias palabras con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para el dictado de texto sin formato
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz que permite a PowerShell escuchar voz
$speechRecogEng = [System.Speech.Recognition.SpeechRecognitionEngine]::new()

#Representar una gramática de reconocimiento de voz utilizada para el dictado de texto sin formato
$speechRecogEng.LoadGrammar([System.Speech.Recognition.DictationGrammar]::new())

#Configurar el motor de sínteris de voz para recibir la entrada desde el dispositivo de audio predeterminado
$speechRecogEng.SetInputToDefaultAudioDevice()

do
{
#Inicia una operación de reconocimiento de voz sincrónico
$speechRecogEng.Recognize()
#Mientras que haya audio
}while($speechRecogEng.AudioFormat)
```

## 4. Reconocer varias palabras contenidas en un fichero de audio con el motor de síntesis de voz en PowerShell utilizando una gramática de reconocimiento de voz para texto sin formato
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz que permite a PowerShell escuchar voz
$speechRecogEng = [System.Speech.Recognition.SpeechRecognitionEngine]::new()

#Representar una gramática de reconocimiento de voz utilizada para el dictado de texto sin formato
$speechRecogEng.LoadGrammar([System.Speech.Recognition.DictationGrammar]::new())

#Configurar el motor de síntesis de voz para recibir la entrada desde un archivo de formato de sonido (.wav)
#El fichero holas2.wav contiene: "Hola, hola. ¿Qué tal estás?. ¿Qué edad tienes?."
$speechRecogEng.SetInputToWaveFile(".\holas2.wav")

do{
#Inicia una operación de reconocimiento de voz sincrónico
$speechRecogEng.Recognize()
#Mientras que haya audio
}while($speechRecogEng.AudioFormat)
```

## 5. Reconocer varias palabras contenidas en un fichero de audio con el motor de síntesis de voz en PowerShell creando las restricciones de una gramática de reconocimiento de voz
```PowerShell
#Cargar los espacios de nombres System.Speech que contienen los tipos que admiten el reconocimiento de voz
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Speech")

#Crear un objeto de tipo motor de síntesis de voz que permite a PowerShell escuchar voz
$speechRecogEng = [System.Speech.Recognition.SpeechRecognitionEngine]::new()

#Crear las restricciones para una gramática de reconocimiento de voz
$speechRecogEng.LoadGrammar([System.Speech.Recognition.GrammarBuilder]::new("Hola"))
$speechRecogEng.LoadGrammar([System.Speech.Recognition.GrammarBuilder]::new("Tal"))
$speechRecogEng.LoadGrammar([System.Speech.Recognition.GrammarBuilder]::new("Edad"))

#Configurar el motor de síntesis de voz para recibir la entrada desde un archivo de formato de sonido (.wav)
$speechRecogEng.SetInputToWaveFile(".\holas2.wav")

do{
#Inicia una operación de reconocimiento de voz sincrónico
$speechRecogEng.Recognize()
Start-Sleep -Seconds 2
#Mientras que haya audio
}while($speechRecogEng.AudioFormat)
```

--------------------

# Reconocimiento

## Utilizar el motor de síntesis de voz en Powershell para analizar audios con voz comparando los resultados entre gramáticas
https://www.jesusninoc.com/2017/12/27/utilizar-el-motor-de-sintesis-de-voz-en-powershell-para-analizar-audios-con-voz-comparando-los-resultados-entre-gramaticas/

## Analizar frecuencias de audio con SDRSharp
https://www.jesusninoc.com/2016/04/29/analizar-frecuencias-de-audio-con-sdrsharp/

## Reproducir notas musicales con PowerShell
https://www.jesusninoc.com/2017/09/23/reproducir-notas-musicales-con-powershell/

## Detectar una frecuencia de sonido emitida desde un dispositivo utilizando la tarjeta de sonido y el programa SDRSharp
https://www.jesusninoc.com/2017/01/01/detectar-una-frecuencia-de-sonido-emitida-desde-un-dispositivo-utilizando-la-tarjeta-de-sonido-y-el-programa-sdrsharp/

## Analizar frecuencias de audio con SDRSharp (reconocer la palabra hola)
https://www.jesusninoc.com/2017/01/31/analizar-frecuencias-de-audio-con-sdrsharp-reconocer-la-palabra-hola/

---------
---------

# Administración y aseguramiento de la información:
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.

# Instalar Windows Server
* https://www.microsoft.com/es-es/evalcenter/evaluate-windows-server-2016

# RAID
* http://www.developandsys.es/aseguramiento-la-informacion/

# Repasar discos en Linux y Windows
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-17.md#comandos-para-trabajar-con-discos-en-linux
## Montar unidades en Windows
* http://www.vicente-navarro.com/blog/2010/10/28/unidades-montadas-y-enlaces-simbolicos-en-windows/

---------------------

# Administración y aseguramiento de la información:
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.
  
# Introducción a las copias de seguridad
## Incremental
* https://github.com/jesusninoc/PowerShell/blob/master/CopiasSeguridad/EjemplosCopiasSeguridad1.ps1
## Diferencial
* https://github.com/jesusninoc/PowerShell/blob/master/CopiasSeguridad/EjemplosCopiasSeguridad2.ps1
    
# PowerShell
## 10. Gestión del rendimiento en PowerShell para administradores de sistemas (nivel básico)
* https://www.jesusninoc.com/11/16/10-gestion-del-rendimiento-en-powershell-para-administradores-de-sistemas/

## Ayuda para copias de seguridad
### Comprimir y descomprimir
* https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Comprimir
* https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/#Descomprimir
```PowerShell
Compress-Archive -LiteralPath C:\powershell\example.txt –CompressionLevel Optimal -DestinationPath C:\powershell\comprimido.zip
Expand-Archive -LiteralPath C:\powershell\comprimido.zip -DestinationPath C:\powershell\descomprimir
Compress-Archive -LiteralPath C:\powershell\example2.txt -Update -DestinationPath C:\powershell\comprimido.zip
```
### Cifrar
* https://www.jesusninoc.com/02/23/aproximacion-al-cifrado-y-descifrado-en-powershell/

## Ejercicios sobre copias de seguridad
- Listar archivos por fecha
  ```PowerShell
  mkdir (Get-Date).ToString("yyyyMMdd")
  cd (Get-Date).ToString("yyyyMMdd")
  Get-ChildItem ../ *.txt | Copy-Item

  Get-ChildItem | select LastWriteTime
  Get-ChildItem ../  | where LastWriteTime -gt (Get-Date).AddDays(-1) | Copy-Item
  ```
- Crear una función que realiza una copia de seguridad en el día de hoy
  ```PowerShell
  ## ¿Qué valores necesita la función? fecha, tipo de archivo y de dónde quiero obtener los archivos
  function copiadeseguridad($fecha,$dedonde,$tipoarchivo)
  {
      mkdir $fecha -Force
      cd $fecha
      Get-ChildItem $dedonde $tipoarchivo | Copy-Item -WhatIf    
  }

  copiadeseguridad -fecha (Get-Date).ToString("yyyyMMdd") -tipoarchivo *.txt -dedonde ../
  ```
- Crear una función que realiza una copia de seguridad en el día de hoy de los archivos que se han modificado respecto del día de ayer
  ```PowerShell
  ## ¿Qué valores necesita la función? fecha de hoy, fecha de ayer, tipo de archivo y de dónde quiero obtener los archivos
  function copiadeseguridad($fechahoy,$fechaayer,$dedonde,$tipoarchivo)
  {
      mkdir $fechahoy -Force
      cd $fechahoy
      Get-ChildItem $dedonde $tipoarchivo | where LastWriteTime -gt $fechaayer | Copy-Item -WhatIf
  }

  copiadeseguridad -fechahoy (Get-Date).ToString("yyyyMMdd") -fechaayer (Get-Date).AddDays(-1) -tipoarchivo *.txt -dedonde ../
  ```
- Copia de seguridad para cada día de la semana y ser capaz de recuperar
  ```PowerShell
  # Restaurar
  mkdir tuscosasperdidas
  cd .\tuscosasperdidas
  Get-ChildItem ../ | Copy-Item
  ```
- Crear una función que realiza una restauración de una copia de seguridad
  ```PowerShell
  function restaurar($fechahoy,$donderestaurar)
  {
      cd $donderestaurar
      Get-ChildItem ("..\"+$fechahoy) | Copy-Item
  }

  restaurar -fechahoy (Get-Date).ToString("yyyyMMdd") -donderestaurar restaurar
  ```
- Ser capaz de recuperar en función de lo que pide el usuario
  ```PowerShell
  # Restaurar en función de lo que pide el usuario
  $datosusar = Read-Host "Dime el nombre del arhcivo que tengo que recuperar"
  ls $datosusar* | Copy-Item
    ```
- Comprimir las copias de seguridad que se han realizado
  ```PowerShell
  # Comprimir el directorio con la fecha
  $fecha = (Get-Date).ToString("yyyyMMdd") + ".zip"
  Compress-Archive -LiteralPath .\20181119 –CompressionLevel Optimal -DestinationPath $fecha
  Compress-Archive -LiteralPath virus.exe -Update -DestinationPath $fecha
  ```

-------------
-------------

# Administración y aseguramiento de la información:
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.

# RAID
* http://www.developandsys.es/aseguramiento-la-informacion/

## Comandos para trabajar con discos en Linux
```Bash
df -h
sudo fdisk -l /dev/sdb
sudo mkfs.vfat /dev/sdc1
sudo mkfs.ntfs /dev/sdc1
sudo mkfs.ext4 /dev/sdc1
sudo blkid
sudo mkdir mount_name
sudo mount -t auto -v /dev/sdb1 /mnt/mount_name
sudo umount /dev/sdb
```
### Borrar copias de seguridad de bases de datos en MySQL.sh

------------
------------

# Preguntas examen liberatorio
- Función que monitoriza
    - https://www.jesusninoc.com/02/01/explicacion-sobre-el-uso-de-funciones-que-estan-en-dll-del-sistema-operativo-en-powershell/
- Función que explica qué hace un proceso

--------------
--------------

# Posibles preguntas examen liberatorio
- Asignar varios permisos a una carpeta
https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-27.md#asignar-varios-permisos-a-una-carpeta
- Asignar varios permisos a distintas carpetas
https://github.com/jesusninoc/ClasesSOM/blob/master/2018-11-27.md#asignar-varios-permisos-a-distintas-carpetas
- Crear carpetas con información sobre los datos obtenidos del hardware.
https://kevinmarquette.github.io/2016-10-28-powershell-everything-you-wanted-to-know-about-pscustomobject/
```PowerShell
$objeto | Get-Member -MemberType NoteProperty | Select -ExpandProperty definition
$objeto | Get-Member -MemberType NoteProperty | Select -ExpandProperty name

$objeto | Get-Member -MemberType NoteProperty | %{
    $_ | Select -ExpandProperty name
    $_ | Select -ExpandProperty definition
}
```
- Carpeta sistemaoperativo con un fichero que tiene la partición donde se ha instalado.
- Carpeta placa_base y dentro de la carpeta un fichero con información.
- Analizar la información de un servicio con capturas de pantalla y comandos de PowerShell.
- Explica la relación entre servicios, procesos y algo más?
- Qué te permite realizar la virtualización en sistemas heterogéneos.
- Cómo harías un script para instalar un gestor virtual y una máquina virtual.
- Es lo mismo ordenar en PowerShell y luego seleccionar que seleccionar y ordenar.
- Qué cantidad de memoria tienes en GB en tu equipo?
- Analiza por qué un proceso tiene tanto consumo de CPU.
- Listar un proceso en Linux desde Powershell.
- Convierte el comando systeminfo a cmdlets en PowerShell.
- Guarda un fichero con la siguiente información: procesos que se están ejecutando, añade una línea con tu nombre al fichero y la hora en que has comprobado los procesos (hazlo tres veces y comprueba que se añaden los datos de las tres ejecuciones).
- Realizar un script que almacene información de cada proceso que se está ejecutando, piensa qué información puede ser interesante.
- Un equipo de la red comienza a realizar comportamientos extraños, realiza un script que pueda detectar qué ocurre y a qué hora.
- Mostrar los servicios que representan comportamientos extraños.
- ¿Cómo puedes darte cuenta de que hay un proceso que consume toda la memoria RAM del equipo?
- Realiza una función de login que almacene los intentos fallidos y correctos.
- Crea una función para hacer un login con dos factores de verificación (incluye comprobar el nombre de usuario).
- Crea una función que intente localizar los hilos que se crean para un proceso.
- Guardar un listado con los ficheros que tenemos en la unidad Q.
- Crear carpetas para cada extensión.
- Carpeta doc y dentro de la carpeta copiar ficheros con extensión doc.
- Añadir a cada carpeta doc, txt un listado con los ficheros y además añadir un listado de permisos.
- Como usuario pedro Crea un fichero con nombre secreto.txt al que únicamente él tenga acceso, tanto de lectura como de escritura.
- Crea otro fichero, también como usuario juan, con nombre datos.txt al que tengan acceso, tanto para leer como para escribir todos los usuarios que pertenezcan al mismo grupo.  Comprueba como usuario pablo que puedes modificar el fichero.
- Como usuario juan, crea un fichero con nombre datos.txt al que pueda acceder cualquier usuario para leer su contenido, y cualquier usuario del mismo grupo para leer o escribir.
- Como usuario pedro, copia un programa del directorio /usr/bin al directorio de trabajo con un nombre diferente. Mira los permisos de este programa. Comprueba que se puede ejecutar.
- Cambia los permisos de un fichero de tal forma que sólo lo pueda ejecutar el propietario del archivo.
- Aparecen unas capturas que se han realizado con la webcam, la webcam esta en estado activo, ¿qué ha ocurrido en el sistema?
- Un empleado sabe que va a ser despedido...
- Realizar la firma de todos los programas que se están ejecutando
- Verificación de contraseña utilizando ficheros en Linux

------------------------

# Examen liberatorio
- Las preguntas que implican respuestas por scripts se pueden hacer en PowerShell, Linux o WSL (o en todos a la vez).
- Utiliza bucles, condiciones, ficheros, funciones, etc.
 
## 1. Realizar un inventario de tu equipo a nivel hardware y software, ten en cuenta cómo clasificar la información y no olvides temas importantes como por ejemplo controladores.
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-12.md
* https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware2.ps1

## 2. Crear una estructura de ficheros en Linux y establece permisos, los permisos tienen que estar establecidos con el mayor criterio posible.
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjercicioPermisos.sh

## 3. Explicar todo lo que sepas sobre virtualización y qué relación tiene con las clases de los jueves.
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-30.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-23.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-16.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-09.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-02.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-26.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-19.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-09-28.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-09-21.md

## 4. Analizar tu equipo desde el punto de vista de los programas, procesos, servicios e hilos.
* https://www.jesusninoc.com/2016/11/10/analizar-servicios-con-powershell/

## 5. Monitorizar un valor de tu equipo.
* https://github.com/jesusninoc/PowerShell/blob/master/Procesos/EjerciciosFuncionesProcesos2.ps1

## 6. Realizar un login implementando autenticación de segundo factor y almacena los intentos de login fallido.
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginIntentosFallidos.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLogin.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginHash.ps1

## 7. Crear carpetas con información sobre los datos obtenidos del hardware.
* https://www.jesusninoc.com/09/07/obtener-informacion-sobre-el-hardware-creando-un-objeto-con-todos-los-datos/
```PowerShell
$objeto | Get-Member -MemberType NoteProperty | %{
    [String]$dire=$_ | Select -ExpandProperty name
    mkdir $dire -Force
    cd $dire
    ni -name informacion.txt -Value ($_ | Select -ExpandProperty definition) -Force
    cd ..
}
```
## 8. Realizar la firma de todos los programas que se están ejecutando.
### Linux
* https://github.com/jesusninoc/ClasesISO/blob/master/2018-11-13.md#calcular-el-hash-sha512-de-todos-los-procesos-que-se-est%C3%A1n-ejecutando-en-linux
### PowerShell función simple
```PowerShell
function hashear($ruta){
    Get-FileHash $ruta
}

Get-Process | select Path | %{
    hashear $_.Path
}
```
### PowerShell función compleja
```PowerShell
function hasheo
{
  param
  (
    [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
    [String[]]
    [AllowEmptyString()] 
    $ruta
  )

  begin
  {
    Write-Host "Principio de hasheo"
  }

  process
  {
    Get-FileHash $ruta
  }
  end
  {
    Write-Host "Final de hasheo"
  }
}

Get-Process | select Path | %{
    hashear $_.Path
}
```
## 9. Analiza por qué un proceso tiene tanto consumo de CPU.
### PowerShell función simple
```PowerShell
function consumo ($nombre,$valor)
{
   if((Get-Process -Name $nombre | select cpu).cpu -gt $valor)
    {
        "$nombre Consume mucho"
    }
    else
    {
        "$nombre No consume mucho"
    }
}

consumo -nombre powershell_ise -valor 10

Get-Process | %{
    consumo -nombre $_.Name -valor 10
}
```
### PowerShell función compleja
```PowerShell
function consumo
{
  param
  (
    [String[]]$nombre,$valor
  )

  begin
  {
    Write-Host "Principio de analizar"
    if($nombre -eq $null)
    {
        "Tiene que introducir un nombre de proceso, majo!"
        break
    }
  }

  process
  {
    if((Get-Process -Name $nombre | select cpu).cpu -gt $valor)
    {
        "$nombre Consume mucho"
    }
    else
    {
        "$nombre No consume mucho"
    }
  }
  end
  {
    Write-Host "Final de analizar"
  }
}

consumo -nombre notepad -valor 10
```
## 10. Simula un login, ten en cuenta que el password se encuentra en SHA512
```Powershell
[Reflection.Assembly]::LoadWithPartialName("System.Web")
[System.Web.Security.FormsAuthentication]::HashPasswordForStoringInConfigFile("Hola", "SHA512")
```
```Powershell
#################################################################################
#Función login de user y pass
#El user y pass (hash en SHA512) correcto se escriben en el bloque BEGIN

#Ejecutar la función
#PS C:\Users\usuario> loginH user pass

function loginH
{
  param
  (
    [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
    [String[]]
    [AllowEmptyString()] 
    $User,$Pass
  )

  begin
  {
    Write-Host "Principio de login"
    $usercorrecto="user"
    #El pass en SHA512
    #$passcorrecto="pass"
    $passcorrecto="5B722B307FCE6C944905D132691D5E4A2214B7FE92B738920EB3FCE3A90420A19511C3010A0E7712B054DAEF5B57BAD
59ECBD93B3280F210578F547F4AED4D25"
  }

  process
  {
   #Realizar el SHA512 del pass introducido por el usuariO
   [Reflection.Assembly]::LoadWithPartialName("System.Web")
   $Pass
   if($User -eq $usercorrecto -and [System.Web.Security.FormsAuthentication]::HashPasswordForStoringInConfigFile($Pass, "SHA512") -eq $passcorrecto)
    {
        $ok=1
    }
    else
    {
        $ok=0
    }
  }
  end
  {
   if($ok)
    {
        Write-Host "User correcto"
    }
    else
    {
        Write-Host "User no correcto"
    }
    Write-Host "Fin de login"
  }
}
#################################################################################
```

------------
------------

# Examen liberatorio
- Las preguntas que implican respuestas por scripts se pueden hacer en PowerShell o Linux (o en los dos a la vez).
- Utiliza bucles, condiciones, ficheros, funciones, etc.
 
## 1. Realizar un inventario de tu equipo a nivel hardware y software, ten en cuenta cómo clasificar la información y no olvides temas importantes como por ejemplo controladores.
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-12.md
* https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Hardware/EjemplosHardware2.ps1

```PowerShell
#Llamadas WMI
$ComputerSystem=Get-WmiObject Win32_ComputerSystem
$BaseBoard=Get-WmiObject Win32_BaseBoard
$BIOS=Get-WmiObject Win32_BIOS
$Processor=Get-WmiObject Win32_Processor
$Battery=Get-WmiObject Win32_Battery
$programas=Get-Package
$controladores=Get-Process -Module
 
#Crear un objeto con todos los datos sobre el hardware
$equipo=[PSCustomObject]@{
 Model = $ComputerSystem.Model
 ManufacturerBoard = $BaseBoard.Manufacturer
 BIOSVersion = $BIOS.SMbiosbiosversion
 BIOSSerialNumber = $BIOS.serialnumber
 ManufacturerProcessor=$Processor.Manufacturer
 MaxClockSpeed=$Processor.MaxClockSpeed
 Cargadelprcesador=$Processor.LoadPercentage
 programas=$programas.name
 conontroladores=$controladores
}

$equipo.programas
$equipo.conontroladores
```

## 2. Crear una estructura de ficheros en Linux y establece permisos, los permisos tienen que estar establecidos con el mayor criterio posible.
* https://github.com/jesusninoc/Bash/blob/master/Permisos/EjercicioPermisos.sh

## 3. Explicar todo lo que sepas sobre virtualización y qué relación tiene con las clases de los jueves.
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-30.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-23.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-11-16.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-09.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-02.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-26.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-10-19.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-09-28.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2017-09-21.md

## 4. Analizar tu equipo desde el punto de vista de los programas, procesos, servicios e hilos.
https://www.jesusninoc.com/2016/11/10/analizar-servicios-con-powershell/

## 5. Monitorizar un valor de tu equipo.
https://github.com/jesusninoc/PowerShell/blob/master/Procesos/EjerciciosFuncionesProcesos2.ps1
```PowerShell
Get-Process | Where-Object PM -GT 50MB
Get-Process | Where-Object CPU -GT 1 | Where-Object PM -GT 50MB
```

## 6. Realizar un login implementando autenticación de segundo factor y almacena los intentos de login fallido.
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginIntentosFallidos.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLogin.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginHash.ps1

```PowerShell
#Login de user y pass
#El user y pass correcto se escriben en el bloque BEGIN

function login0
{
  param([Parameter(Mandatory=$true, ValueFromPipeline=$true)][String[]][AllowEmptyString()]$User,$Pass,$Pass2)

  begin
  {
    Write-Host "Principio de login"
    $usercorrecto="jaime"
    $passcorrecto="hola"
    $passcorrecto2=gc .\pin.txt
  }

  process
  {
   if($User -eq $usercorrecto -and $Pass -eq $passcorrecto -and $Pass2 -eq $passcorrecto2)
    {
        $ok=1
    }
    else
    {
        $ok=0
    }
  }
  end
  {
   if($ok)
    {
        Write-Host "User correcto"
    }
    else
    {
        Write-Host "User no correcto"
        $User,$Pass,$Pass2 | Out-File log.txt -Append
    }
    Write-Host "Fin de login"
  }
}

#Ejecutar la función: login0
login0 -User jaime -Pass hola -Pass2 1234
```

-------------------------

# Examen liberatorio II

## Realizar una función de muestre el consumo de procesador analizando dos valores (consumo -cpu 20 -id 6000)

```PowerShell
# Sirve para ir de uno en uno
(Get-Process | select $proceso).cpu -gt $valor

# Varios valores
Get-Process | Where-Object cpu -gt 10 | Where-Object id -gt 6000
```

## Realizar una función que permita detectar que hay una firma igual a otra

```PowerShell
# Función simple para almacenar un hash de un programa
function hashear($ruta){
    Get-FileHash $ruta
}

(hashear 'C:\Windows\System32\notepad.exe' | select hash).hash | Out-File hash.txt

(gc hash.txt)

Get-Process | select Path | %{
    hashear $_.Path
}

Get-Process | select Path | %{
    (hashear $_.Path).hash
}

Get-Process | select Path | %{
    if ((hashear $_.Path).hash -match (gc hash.txt))
    {
        "Igual",$_.path
    }
}
```

## Realizar una función que muestre información sobre los hilos de un proceso

```PowerShell
function hilos($name){
    $processHandle = (Get-Process -Name $name).id
    $Threads = Get-WmiObject -Class Win32_Thread |
    Where-Object { $_.ProcessHandle -eq $processHandle }
    "The $name process has $($threads.count) threads"
    $threads | Format-Table -Property priority, thread*, User*Time, kernel*Time
}

hilos notepad
```

## Realizar una función que muestre los procesos que utilizan un controlador
```PowerShell
Get-Process -Module | select-string "OLEAUT32.dll"

Get-Process -Module | %{
    $_ | select-string "OLEAUT32.dll"
}

Get-Process | select name,Modules  | %{
    $_.name
    $_.Modules.ModuleName | select-string "OLEAUT32.dll"
}

Get-Process | select name,Modules | %{
    if($_.Modules.ModuleName -eq "OLEAUT32.dll")
    {
        $_.Name,$_.Modules.ModuleName
    }
}
```

------------------

# Examen de la primera evaluación

## Crear carpetas para cada extensión
```PowerShell
# Crear carpetas para cada extensión.

function extensiones
{
  param
  (
    [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
    [String[]]
    $ruta
  )

  begin
  {
    Write-Host "Begin de extensión"
    $var = ls $ruta | select Extension
  }

  process
  {
    $var | %{
        mkdir $_.Extension
    }
  }
  end
  {
    Write-Host "Final de extensión"
    Get-ChildItem
  }
}

extensiones ../
```
## Carpeta txt y dentro de la carpeta copiar ficheros con extensión txt
```PowerShell
function txt
{
  param
  (
    [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
    [String[]]
    $ruta
  )

  begin
  {
    Write-Host "Begin de txt"
    mkdir txt
  }

  process
  {
    Copy-Item -Path $ruta -Destination txt -Force -WhatIf
  }
  end
  {
    Write-Host "Final de txt"
    Get-ChildItem
  }
}

txt ../*.txt
```
## Realiza una función de login que almacene los intentos fallidos y correctos
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginIntentosFallidos.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLogin.ps1
* https://github.com/jesusninoc/PowerShell/blob/master/Funciones/EjerciciosFuncionesAvanzadasLoginHash.ps1

## Mostrar los servicios que representan comportamientos extraños
* https://www.jesusninoc.com/11/10/analizar-servicios-con-powershell/

------------------

# Repaso operaciones básicas en Bash y PowerShell
* https://github.com/jesnino/Bash/blob/master/Introduccion/EjemplosOperacionesCadenas.sh
* https://www.jesusninoc.com/2008/09/29/ejemplos-de-ejecucion-de-comandos-en-bash-y-powershell-parte-1/
* https://www.jesusninoc.com/2008/09/30/ejemplos-de-ejecucion-de-comandos-en-bash-y-powershell-parte-2/
* https://www.jesusninoc.com/2008/10/01/ejemplos-de-ejecucion-de-comandos-en-bash-y-powershell-parte-3/

# Hacer ejercicios en PowerShell
## Ejercicio de PowerShell | Crear diccionario
* https://www.youtube.com/watch?v=Pl2lK4urW3Q&list=PL89qBrmFzAa34fM6OEMLV6ybDk3Y34qud&index=2
* https://www.jesusninoc.com/2016/06/07/ejercicios-de-powershell-crear-un-diccionario/

# Enviar un mensaje entres varios equipos
### Cliente
```PowerShell
    ##Client
    $ip=[IPAddress]"127.0.0.1"
    $TcpClient=New-Object System.Net.Sockets.TcpClient($ip, "2050")
    $mensaje=New-Object System.IO.StreamWriter $TcpClient.GetStream()
    $mensaje.Write("echo hol2222a")
    $mensaje.Dispose()
```
### Servidor y cliente
```PowerShell
##Server
$ip=[IPAddress]"0.0.0.0"
$TcpListener=New-Object System.Net.Sockets.TcpListener (New-Object System.Net.IPEndPoint($ip,"2050"))
$TcpListener.Start()
 
while($true)
{
$mensaje2=(New-Object System.IO.StreamReader ($TcpListener.AcceptTcpClient().GetStream())).ReadLine()
$mensaje2
##Client
$ip=[IPAddress]"192.168.204.222"
$TcpClient=New-Object System.Net.Sockets.TcpClient($ip, "2051")
$mensaje=New-Object System.IO.StreamWriter $TcpClient.GetStream()
$mensaje.Write($mensaje2)
$mensaje.Dispose()
}
$TcpListener.Stop()
```
### Servidor que ejecuta
```PowerShell
##Server
$ip=[IPAddress]"0.0.0.0"
$TcpListener=New-Object System.Net.Sockets.TcpListener (New-Object System.Net.IPEndPoint($ip,"2051"))
$TcpListener.Start()
 
while($true)
{
$mensaje=(New-Object System.IO.StreamReader ($TcpListener.AcceptTcpClient().GetStream())).ReadLine()
$mensaje | iex
}
$TcpListener.Stop()
```

-------------
-------------

# Examen liberatorio
- Las preguntas que implican respuestas por scripts se pueden hacer en PowerShell o Linux (o en los dos a la vez).
- Utiliza bucles, condiciones, ficheros, funciones, etc.

# Preguntas
- Realizar una función que compare dos hashes.
- Obtener información sobre el sistema operativo.
- Guardar en un fichero comprimido información sobre el sistema operativo.
- Hacer un login registrando los intentos (el password se tiene que almacenar hash).
- ¿Cómo puedes detectar un problema en un sistema operativo relacionado con la ejecución de procesos?
- Mover carpetas impares
- Crear una copia de sguriad y restaurar

# Resolver las siguientes situaciones
- Hacer un login (registrar los intentos fallidos) que permita acceder a un sistema que realiza una copia de seguridad comprimida sobre información sobre el sistema (realizar la copia de seguridad).
```PowerShell
function copia()
{
    Get-Process > procesos.txt
    Compress-Archive -Path .\procesos.txt -DestinationPath aqui.zip -CompressionLevel Fastest -Force
}

$usuario = "juan"
$pass = "juan"
if($usuario -eq "juan" -and $pass -eq "juan")
{
    copia
}
```
- El sistema de copia de seguridad está fallando. ¿Cómo puedes detectar un problema en un sistema operativo relacionado con la ejecución de procesos? Haz una simulación de la situación.
```PowerShell
# Función que simula copia de seguridad
function copiaseguridad()
{
    Start-Sleep -Seconds 8
    Compress-Archive -Path .\123-10.txt -DestinationPath aqui.zip -CompressionLevel Fastest -Force
}

copiaseguridad

# En PowerShell distintos
(Get-Process -Name powershell_ise).Threads.Count
```

# Soluciones avanzadas

## Obtener información sobre el sistema operativo y enviarla por la red

### Servidor
```PowerShell
##Server
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Any,$port)
$udpclient=new-Object System.Net.Sockets.UdpClient $port
$content=$udpclient.Receive([ref]$endpoint)
[Text.Encoding]::ASCII.GetString($content)
$udpclient.Dispose()
```

### Cliente
```PowerShell
Function menu {
    Clear-Host
    Write-Host "Iniciando el menu..."
    Write-Host "1. Información del hardware"
    Write-Host "2. Información de procesos"
    Write-Host "3. Ver registros de usuarios"
    Write-Host "4. Ver actualizaciones del sistema"
    Write-Host "5. Ver programas instalados"
    Write-Host "6. Salir"
}
1
menu

while($inp = Read-Host -Prompt "Escoge una accion"){

switch($inp){
        1{  $extension = Read-Host -Prompt "Pulse para analizar los componentes hardware de su pc"
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Loopback,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=[Text.Encoding]::ASCII.GetBytes('$ComputerSystem=Get-WmiObject Win32_ComputerSystem
            $BaseBoard=Get-WmiObject Win32_BaseBoard
            $BIOS=Get-WmiObject Win32_BIOS
            $Processor=Get-WmiObject Win32_Processor
            $Battery=Get-WmiObject Win32_Battery
            [PSCustomObject]@{
             Nombre=$Processor.Name
             Model = $ComputerSystem.Model
             Name = $ComputerSystem.Name
             PrimaryOwnerName = $ComputerSystem.primaryownername
             Totalphysicalmemory = $ComputerSystem.totalphysicalmemory
             ManufacturerBoard = $BaseBoard.Manufacturer
             BIOSVersion = $BIOS.SMbiosbiosversion
             BIOSSerialNumber = $BIOS.serialnumber
             version = $BaseBoard.version
             ManufacturerProcessor=$Processor.Manufacturer
             MaxClockSpeed=$Processor.MaxClockSpeed
             DeviceIDBattery=$Battery.DeviceID.trim()
             Designvoltaje=$Battery.designvoltage
             NumberOfCores=$Processor.NumberOfCores
             NumberOfLogicalProcessors=$Processor.NumberOfLogicalProcessors
             NumberOfEnabledCore=$Processor.NumberOfEnabledCore
             LoadPercentage=$Processor.LoadPercentage
             }')
             $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
             $udpclient.Close()
            pause;
            break
        }
        2       
        {  
            $extension = Read-Host -Prompt "Pulse para analizar los procesos de su pc"
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Loopback,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=[Text.Encoding]::ASCII.GetBytes('Get-WmiObject -Class win32_process | select name, Path, ExecutablePath, CommandLine | Format-Custom')
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()
            pause; 
            break
        }
        3
        {
         
            $extension = Read-Host -Prompt "Introduzca el nombre del equipo"
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Loopback,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=[Text.Encoding]::ASCII.GetBytes('$logs = get-eventlog system -ComputerName "$extension" -source Microsoft-Windows-Winlogon -After (Get-Date).AddDays(-7);
            $res = @(); ForEach ($log in $logs) {if($log.instanceid -eq 7001) {$type = "Logon"} Elseif ($log.instanceid -eq 7002){$type="Logoff"} Else {Continue} $res += New-Object PSObject -Property @{Time = $log.TimeWritten; "Event" = $type; User = (New-Object System.Security.Principal.SecurityIdentifier $Log.ReplacementStrings[1]).Translate([System.Security.Principal.NTAccount])}};
            $res')
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()
        }

      
      
        6 {"Exit"; break}
        default {Write-Host -ForegroundColor red -BackgroundColor white "Invalid option. Please select another option";pause}
        
    }

menu
}
```

----------------
----------------

# Examen subida de nota

## Utilizando funciones, resolver la siguiente situación: 

- Solo puedes utilizar el script si eres un usuario reconocido
- Si eres un usuario reconocido preguntas al usuario qué quiere, opciones:
    - Opción 1. Te indica si se ha ejecutado una compresión en el sistema
    - Opción 2. Te cuenta el número de hilos que se están ejecutando en el sistema

## Solución
```PowerShell
$usuario = "juan"
$password = "1234"

if($usuario -eq (Read-Host "Intro usuario") -and $password -eq (Read-Host "Intro pass"))
{
    "Estás dentro"
    switch(Read-Host "- Opción 1. Te indica si se ha ejecutado una compresión en el sistema
- Opción 2. Te cuenta el número de hilos que se están ejecutando en el sistema" 
)
    {
        "1"{
            #while(1)
            #{
                Get-Process -Name WinRAR -OutVariable resultado
                if($resultado)
                {
                    "Se ha comprimido"
                }
                else
                {
                    "No se ha comprimido"
                }
            #}
        }
        "2"{(Get-Process).Threads.Count}
    }
}
```

------------------

# Cliente-Servidor

## Comunicación entre cliente y servidor
* https://www.jesusninoc.com/2015/02/25/creating-reverse-shell/
* https://www.jesusninoc.com/2015/02/26/creating-shell/
* https://www.jesusninoc.com/2017/10/18/crear-una-comunicacion-entre-un-cliente-en-bash-de-linux-y-un-servidor-en-powershell-de-windows-utilizando-tcpip/
* https://www.jesusninoc.com/2017/10/26/crear-una-comunicacion-entre-un-cliente-en-powershell-de-windows-y-un-servidor-en-bash-de-linux-utilizando-tcpip/
* https://www.jesusninoc.com/2016/04/30/simular-el-funcionamiento-de-un-servidor-web-utilizando-netcat-en-linux/
* https://www.jesusninoc.com/2009/06/06/ejecutar-nc-exe-cmd-exe-remotamente/

## Servidor desde PowerShell
https://www.jesusninoc.com/2017/05/06/crear-un-servidor-web-al-que-se-pueda-acceder-desde-cualquier-parte-de-la-red-privada-con-powershell/

## Utilizando la comunicación remota entre cliente y servidor simular una conexión a una shell y una reverse shell
* https://www.jesusninoc.com/01/27/ejecutar-un-cmdlet-remotamente-en-un-equipo-utilizando-sockets-udp/
* https://www.jesusninoc.com/2015/02/25/creating-reverse-shell/
* https://www.jesusninoc.com/2015/02/26/creating-shell/

## Ejecutar un comando remotamente utilizando un servidor web creado en PowerShell
```Powershell
$routes = @{
    "/" = { return '<html><body>Servidor web funcionando</body></html>' }
}

#Importante poner la IP de la red privada
$url = 'http://192.168.204.222:8027/'
$listener = New-Object System.Net.HttpListener
$listener.Prefixes.Add($url)
$listener.Start()

Write-Host "Funcionando $url..."

while ($listener.IsListening)
{
    $context = $listener.GetContext()
    $requestUrl = $context.Request.Url
    $response = $context.Response

    Write-Host ''
    Write-Host "Petición: $requestUrl"

    $localPath = $requestUrl.LocalPath
    $route = $routes.Get_Item($requestUrl.LocalPath)

    if ($route -eq $null)
    {
        $response.StatusCode = 404
    }
    else
    {
        
        $content = & $route
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($content)
        $response.ContentLength64 = $buffer.Length
        $response.OutputStream.Write($buffer, 0, $buffer.Length)
    }
    
    $response.Close()
    start-process ($context.Request.RawUrl -replace "/")
    $context.Request.RawUrl
    $responseStatus = $response.StatusCode
    Write-Host "Respuesta: $responseStatus"
}
```

--------------
--------------

# Examen de evaluación

## Posibles preguntas
- Crear un script que mediante un login (que lee de un fichero) el usuario introduzca una opción y si es 1 añada un fichero a un fichero comprimido.

## Exámenes para repasar

* https://github.com/jesusninoc/ClasesISO/blob/master/2019-12-03.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-12-04.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-12-05.md
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-12-12.md

## Temario que entra en el examen de evaluación

### Instalación de software libre y propietario

- Estructura de un sistema informático. Monolítica. Jerárquica. Capas o anillos (ring). Máquinas virtuales. Cliente-servidor.
- Arquitectura de un sistema operativo. Sistemas por lotes (batch). Sistemas por lotes con multiprogramación. Sistemas de tiempo compartido. Sistemas distribuidos.
- Funciones de un sistema operativo.
  - Controlar y gestionar el uso del hardware del ordenador: CPU, dispositivos de E/S, Memoria principal, tarjetas gráficas y el resto de periféricos.
  - Administrar la ejecución de los procesos. Planificación.
  - Controlar el proceso de organización de la información. Creación, acceso (ubicación física) y borrado de archivos.
  - Controlar el acceso de los programas o los usuarios a los recursos del sistema.
  - Proporcionar interfaces de usuario: en modo texto y gráficos.
  - Servicios soporte: actualizaciones de software, controladores para nuevos periféricos, etc.
- Tipos de sistemas operativos.
  - Monousuario o multiusuario
  - Centralizado o distribuido
  - Monotarea o multitarea
  - Uniprocesador o multiprocesador
  - Instalables y/o autoarrancables.
- Sistemas operativos libres.
- Sistemas operativos propietarios.
- Tipos de aplicaciones. Software de sistema. Software de programación. Software de aplicación.
- Licencias y tipos de licencias. Según los derechos que cada autor se reserva sobre su obra. Según su destinatario.
- Máquinas virtuales (M.V.)
  - Concepto de virtualización del hardware y características de los principales productos software libre y propietario, para el uso de máquinas virtuales.
  - Creación y personalización de M.V.
  - Ventajas e inconvenientes de la virtualización.
- Consideraciones previas a la instalación de sistemas operativos libres y propietarios.
  - Particionado del disco duro.
  - En sistemas Windows determinar la partición donde instalaremos el S.O.
  - En sistemas Linux determinar las particiones para los distintos puntos de montaje.
  - Controladores (drivers) de almacenamiento necesarios.
- Instalación de sistemas operativos.
  - Requisitos hardware, versiones y licencias.
  - Soporte utilizado para la instalación: CD/DVD, Pendrive, LAN.
  - Datos necesarios para la instalación: usuarios, contraseñas, nombre del equipo, direcciones IP, número de licencia, etc.
- Gestión de varios sistemas operativos en un ordenador.
  - Requisitos previos. Administración del espacio del disco. Particionado y redimensionado.
  - Problemas con el registro maestro de arranque (MBR). Elegir un gestor de arranque compatible con todos los sistemas operativos a instalar.
  - Preparar las particiones de los S.O. para permitir su arranque.
  - Analizar el orden en la instalación de los sistemas operativos.
- Gestores de arranque.
  - Código de arranque maestro (Master Boot Code).
  - Formatos tabla de particiones. Master Boot Record (MBR) y Guid Partition Table (GPT).
  - Configuración de los gestores de arranque de los sistemas operativos libres y propietarios.
  - Reparación del gestor de arranque.
  - Sustitución del gestor de arranque estándar por otro más completo.
- Instalación/desinstalación de aplicaciones. Requisitos hardware y software, versiones y licencias.
- Actualización de sistemas operativos y aplicaciones.
  - Actualizar a una versión superior (update).
  - Cambiar a una versión inferior (downgrade).
  - Instalación de parches: de seguridad, funcionales, opcionales, etc.
  - Automatizar las actualizaciones. Configurar la fuente de las actualizaciones.
- Ficheros necesarios para el arranque de los principales sistemas operativos.
- Registros (logs) del sistema.
  - Formato de los registros: fuente/origen, prioridades (informativos, advertencias, errores, etc.)
  - Herramientas para su monitorización en sistemas libres y propietarios.
  - Gestión: Aplicar filtros, asociar tareas en respuesta a ciertos eventos, etc.
- Actualización y mantenimiento de controladores de dispositivos.
  - Automatizar la actualización de controladores.
  - Volver a una versión anterior de un controlador.
  - Actualización manual de los controladores.
  
 ### Administración y aseguramiento de la información
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.
- Identificación del software instalado mediante comandos y herramientas gráficas.
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.
- Implementación RAID por software:
  - Operaciones con volúmenes: extender y distribuir.
  - Aumentar la velocidad.
  - Tolerancia a fallos. Simular un fallo de disco para comprobar la tolerancia del sistema.
  - Detectar fallos consultando los registros del sistema.
  - Programar alertas por correo.
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

--------------
--------------

# Correción del examen
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-12-03.md#preguntas-examen-liberatorio
* https://github.com/jesusninoc/ISO-1/blob/main/Examen%20liberatorio
## Soluciones
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-crear-una-funcion-simple-para-monitorizar-procesos-version-1-con-where/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-crear-una-funcion-simple-para-monitorizar-procesos-version-2-con-foreach/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-crear-una-funcion-simple-para-monitorizar-procesos-version-3-creando-una-carpeta-con-la-informacion-obtenida-cada-24-horas/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-crear-una-funcion-simple-para-monitorizar-procesos-version-4-pasando-como-parametro-el-proceso-a-monitorizar/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-crear-una-funcion-simple-para-monitorizar-procesos-version-5-pasando-como-parametro-cada-proceso-que-se-ejecuta-y-monitorizando-cada-24-horas/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-obtener-informacion-sobre-los-procesos-que-se-estan-ejecutando-que-hace-un-proceso/
* https://www.jesusninoc.com/12/10/ejercicios-de-powershell-obtener-informacion-sobre-los-procesos-que-se-estan-ejecutando-analizando-las-dll-que-ejecuta-que-hace-un-proceso/

## Examen subida de nota: realizar un ejercicio sobre copias de seguridad en Linux, utilizando como idea la solución en PowerShell (primer enlace)
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-12-10.md#ejercicio-sobre-copias-de-seguridad-con-integridad-comprobar-que-los-ficheros-que-tengo-en-una-carpeta-son-correctos-en-la-copia-de-seguridad-mediante-la-integridad
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-12-10.md#ejercicios-sobre-copias-de-seguridad

--------
--------

# Administración y aseguramiento de la información
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

---------------

# Ficheros en Linux

## Introducción a buscar ficheros
* https://github.com/jesnino/Bash/blob/master/Ficheros/EjerciciosFicherosBuscar.sh

## Conocer la extensión de un fichero en Linux
```Bash
file fichero
```

## Ejercicio calcular hash en Linux
```Bash
proceso=`ps -C nano -o cmd --no-headers`
ruta=`whereis $proceso`
sha512sum $ruta
```

## Introducción a bucles en Linux
* https://www.jesusninoc.com/2015/07/13/bucles-2/
* https://www.jesusninoc.com/2016/01/02/for-loop-examples/

## Bucle for en Linux
```Bash
for i in $(pgrep application.x); do ps -mo pid,tid,fname,user,psr -p $i;done
```

## Ver funcionamiento de awk
```Bash
echo "hola amigo" | awk '{print $1}'
echo "hola amigo" | awk '{print $2}'
echo "touch amigo" | awk '{print $1}'; echo "touch amigo" | awk '{print $2}'
```

## Calcular el hash SHA512 de todos los procesos que se están ejecutando en Linux
```Bash
for procesos in $(ps -aux | awk '{print $11}');do ruta=`whereis $procesos`; sha512sum $ruta;done
```

-------------

# Ficheros en PowerShell

## Listar ficheros cuya fecha de última escritura de ficheros sea de mayor que menos un día
```PowerShell
Get-ChildItem | where LastWriteTime -gt (Get-Date).AddDays(-1)
```
## Listar ficheros cuyo tamaño sea mayor de 1MB
```PowerShell
Get-ChildItem -Recurse | where Length -Gt 1MB
```
## Listar la ruta de los programas que se están ejecutando
```PowerShell
foreach($procesos in (Get-Process | select path))
{
    Get-FileHash $procesos.path
}
```
## Listar la ruta del programa Chrome que se está ejecutando
```PowerShell
foreach($id in Get-Process -Name chrome)
{
    Get-FileHash $id.Path
}
```

---------------

# Linux

## Copias de seguridad
* http://www.developandsys.es/copias-seguridad-linux/

## Programar la copia de seguridad
* https://github.com/jesusninoc/Bash/blob/master/Examenes/Examen-2016-02-11-Solucion.sh

## Ejercicios sobre copias de seguridad
- Listar archivos por fecha
  ```Bash
  ls -lt
  ls -ltr
  ls -l --sort=size
  ```
- Copia de seguridad para cada día de la semana y ser capaz de recuperar
  * https://www.youtube.com/watch?v=aDCfL9Pk3TQ&feature=youtu.be
  * https://github.com/jesnino/Bash/blob/master/Ficheros/EjercicioCalendario.sh
- Copiar cada fichero listado de un directorio en un nuevo directorio
  * https://github.com/jesusninoc/ClasesISO/blob/master/2019-01-22.md#utilizar-xargs
- Comprimir las copias de seguridad que se han realizado
  * https://linuxzone.es/metodos-de-compresion-y-descompresion-en-linux/
- Enviar un mail cuando se haya realizado la copia de seguridad
  * https://www.interserver.net/tips/kb/linux-mail-command-usage-examples/

## Copias de seguridas de bases de datos

### MySQL dump ignorando tablas
* https://github.com/jesusninoc/Scripts/blob/master/MySQL%20dump%20ignorando%20tablas.sh

### MySQL dump completo
* https://github.com/jesusninoc/Scripts/blob/master/MySQL%20dump%20completo.sh

### Borrar copias de seguridad de bases de datos en MySQL.sh
* https://github.com/jesusninoc/Scripts/blob/master/Borrar%20copias%20de%20seguridad%20de%20bases%20de%20datos%20en%20MySQL.sh

### Database Backup Program (examples)
* https://www.jesusninoc.com/11/26/database-backup-program-scripts-examples/

-----------------

# PowerShell

## Ejercicio sobre copias de seguridad con integridad: comprobar que los ficheros que tengo en una carpeta son correctos en la copia de seguridad mediante la integridad

```PowerShell
# Ideas

# Probar la integridad de las copias de seguridad:
# - Crear un plan de pruebas. 
# - Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
# - Comprobar si los tiempos de restauración son asumibles.

# Ficheros que se van a copiar
# fichero1.txt
# fichero2.txt
# fichero3.txt
# fichero4.txt

# Ficheros que tienen las integridades de los ficheros 1,2,3,4
# fichero1integridad.txt
# fichero2integridad.txt
# fichero3integridad.txt
# fichero4integridad.txt

# crear el zip 1,2,3,4

# -------------------- RECUPERACIÓN

# descomprimir zip 1,2,3,4

# ver integridad fichero que tiene los hashes 1,2,3,4

# fichero1 si abro si la integridad es correcta

"hola" > fichero1.txt
(Get-FileHash .\fichero1.txt).hash
(Get-FileHash .\fichero1.txt).hash > fichero1integridad.txt

# zip meter fichero1.txt más integridades.txt (se puede separar en dos archivos)

# hay fallo y tengo que recuperar la copia

# descomprimir y ver si el fichero1.txt lo puedo ver

# porque la integridad de fichero1 es correcta

# h(f1) == f1*

if((gc .\fichero1integridad.txt) -eq (Get-FileHash .\fichero1.txt).hash)
{
    "El hash coincide"
}
else
{
    "El hash no coincide"
}

# Ver si el hash coincide para todos los ficheros

mkdir ficheros
cd .\ficheros
"hola" > fichero1.txt
(Get-FileHash .\fichero1.txt).hash
(Get-FileHash .\fichero1.txt).hash > fichero1integridad.txt
"holas" > fichero2.txt
(Get-FileHash .\fichero2.txt).hash
(Get-FileHash .\fichero2.txt).hash > fichero2integridad.txt

# Se supone que se ha comprimido

# Hay fallo
 
# Verificar que todos los hashes son correctos

ls fichero?.txt | %{
    $ficherointeg = $_.FullName
    $ficherointeg2 = $ficherointeg.replace(".txt","")
    $ficherofinal = ([String]$ficherointeg2+"integridad.txt")

    if(((Get-FileHash $_).hash) -eq (gc $ficherofinal))
    {
        "El hash coincide"
    }
    else
    {
        "El hash no coincide"
    }
}
```

-------------
-------------

# Repaso evaluación
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-12-05.md#resolver-las-siguientes-situaciones

----------

# Administración y aseguramiento de la información
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

---------------

# PowerShell

## Ejercicio sobre copias de seguridad con integridad: comprobar que los ficheros que tengo en una carpeta son correctos en la copia de seguridad mediante la integridad

```PowerShell
# Ideas

# Probar la integridad de las copias de seguridad:
# - Crear un plan de pruebas. 
# - Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
# - Comprobar si los tiempos de restauración son asumibles.

# Ficheros que se van a copiar
# fichero1.txt
# fichero2.txt
# fichero3.txt
# fichero4.txt

# Ficheros que tienen las integridades de los ficheros 1,2,3,4
# fichero1integridad.txt
# fichero2integridad.txt
# fichero3integridad.txt
# fichero4integridad.txt

# crear el zip 1,2,3,4

# -------------------- RECUPERACIÓN

# descomprimir zip 1,2,3,4

# ver integridad fichero que tiene los hashes 1,2,3,4

# fichero1 si abro si la integridad es correcta

"hola" > fichero1.txt
(Get-FileHash .\fichero1.txt).hash
(Get-FileHash .\fichero1.txt).hash > fichero1integridad.txt

# zip meter fichero1.txt más integridades.txt (se puede separar en dos archivos)

# hay fallo y tengo que recuperar la copia

# descomprimir y ver si el fichero1.txt lo puedo ver

# porque la integridad de fichero1 es correcta

# h(f1) == f1*

if((gc .\fichero1integridad.txt) -eq (Get-FileHash .\fichero1.txt).hash)
{
    "El hash coincide"
}
else
{
    "El hash no coincide"
}

# Ver si el hash coincide para todos los ficheros

mkdir ficheros
cd .\ficheros
"hola" > fichero1.txt
(Get-FileHash .\fichero1.txt).hash
(Get-FileHash .\fichero1.txt).hash > fichero1integridad.txt
"holas" > fichero2.txt
(Get-FileHash .\fichero2.txt).hash
(Get-FileHash .\fichero2.txt).hash > fichero2integridad.txt

# Se supone que se ha comprimido

# Hay fallo
 
# Verificar que todos los hashes son correctos

ls fichero?.txt | %{
    $ficherointeg = $_.FullName
    $ficherointeg2 = $ficherointeg.replace(".txt","")
    $ficherofinal = ([String]$ficherointeg2+"integridad.txt")

    if(((Get-FileHash $_).hash) -eq (gc $ficherofinal))
    {
        "El hash coincide"
    }
    else
    {
        "El hash no coincide"
    }
}
```

## Programar la copia de seguridad
* https://www.jesusninoc.com/2017/03/01/tareas-programadas-en-powershell/
* https://github.com/jesusninoc/PowerShell/blob/master/TareasProgramadas/EjemploTareaProgramada.ps1

## Ejercicio: crear una tarea programada que ejecuta un script en PowerShell que realiza una copia de seguridad
### Crear una copia de seguridad
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-11-26.md#ejercicio-sobre-copias-de-seguridad-con-integridad-comprobar-que-los-ficheros-que-tengo-en-una-carpeta-son-correctos-en-la-copia-de-seguridad-mediante-la-integridad
* https://www.jesusninoc.com/12/08/crear-una-tarea-programada-en-windows-que-ejecute-un-script-de-powershell-cada-10-minutos-de-forma-indefinida-aunque-el-porcentaje-de-bateria-sea-bajo/
### Tener en cuenta a la hora de programar la tarea que ejecuta el script
```PowerShell
# Cambiar la política de ejecución de scripts para poder ejecutar
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser

# Ecribir un mensaje por pantalla
echo "hola"

# Mostrar la ruta
pwd

# Parar el script
pause

# Almacenar en un fichero la hora a la que se ejecuta el script junto con el porcentaje de batería
echo (Get-Date).Hour >> C:\xampp\mysql\bin\fichero.txt
```
### Repetir cada 1 hora indefinidamente la ejecución de un script en PowerShell
```PowerShell
$Sta = New-ScheduledTaskAction -Execute "powershell"
$Stt = New-ScheduledTaskTrigger -Once -At 19pm -RepetitionInterval (New-TimeSpan -hour 1)
Register-ScheduledTask Task01 -Action $Sta -Trigger $Stt
```

-------------
-------------

# Clase especial

## Instalar Icecast is free server software for streaming multimedia
```Bash
sudo apt-get install icecast2 darkice
```

## Descargar un mp4 y un mp3 en la carpeta /usr/share/icecast2/web
```Bash
wget https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3
```

## Reproducir ficheros desde el móvil
http://192.168.1.162:8000/sound.mp3

## Download videos from YouTube (youtube-dl)
https://www.jesusninoc.com/2014/10/18/download-videos-youtube/

## Subir a un servidor el contenido generado en PowerShell
https://www.jesusninoc.com/2017/11/02/subir-un-fichero-por-ssh-a-un-servidor-linux-desde-powershell-en-windows/

## Descargar ficheros de un servidor Linux desde PowerShell
https://www.jesusninoc.com/2017/11/04/descargar-un-fichero-por-ssh-de-un-servidor-linux-desde-powershell-en-windows/

## Cortar un vídeo
https://github.com/jesusninoc/Scripts/blob/master/Cortar%20un%20v%C3%ADdeo.sh

## Convertir a texto un audio en formato WAV
https://www.jesusninoc.com/08/15/convertir-audio-en-formato-wav-a-texto-version-15-08-2015/

## Reconocimiento de voz a texto
https://www.jesusninoc.com/06/26/reconocimiento-de-patrones-utilizando-powershell/#Reconocimiento_de_voz_a_texto

---------------------

# Clase especial

## Instalar Icecast is free server software for streaming multimedia
```Bash
sudo apt-get install icecast2 darkice
```

## Descargar un mp4 y un mp3 en la carpeta /usr/share/icecast2/web
```Bash
wget https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3
```

## Reproducir ficheros desde el móvil
http://192.168.1.162:8000/sound.mp3

## Download videos from YouTube (youtube-dl)
https://www.jesusninoc.com/2014/10/18/download-videos-youtube/

## Subir a un servidor el contenido generado en PowerShell
https://www.jesusninoc.com/2017/11/02/subir-un-fichero-por-ssh-a-un-servidor-linux-desde-powershell-en-windows/

## Descargar ficheros de un servidor Linux desde PowerShell
https://www.jesusninoc.com/2017/11/04/descargar-un-fichero-por-ssh-de-un-servidor-linux-desde-powershell-en-windows/

## Cortar un vídeo
https://github.com/jesusninoc/Scripts/blob/master/Cortar%20un%20v%C3%ADdeo.sh

## Convertir a texto un audio en formato WAV
https://www.jesusninoc.com/08/15/convertir-audio-en-formato-wav-a-texto-version-15-08-2015/

## Reconocimiento de voz a texto
https://www.jesusninoc.com/06/26/reconocimiento-de-patrones-utilizando-powershell/#Reconocimiento_de_voz_a_texto

---------------------

# Ejercicio 

## Partir en trozos un audio en MP3, convertirlos en WAV y después convertir a texto el audio

### Partir en trozos un audio en MP3 y convertirlos en WAV
```CMD
ffmpeg -i audio.mp3 -ss 70 -t 113 miaudio_cortado.mp3
ffmpeg -i song.mp3 -acodec pcm_u8 -ar 22050 song.wav
```

#### Versión 1
```PowerShell
[void][reflection.assembly]::LoadWithPartialName(‘system.speech’)

$rec = New-Object ‘System.Speech.Recognition.SpeechRecognitionEngine’
$rec.LoadGrammar((New-Object ‘System.Speech.Recognition.DictationGrammar’))
$rec.SetInputToWaveFile("C:\Users\ajnino\Downloads\ffmpeg-20191120-d73f062-win32-static\ffmpeg-20191120-d73f062-win32-static\bin\song.wav")
[String]$almacenarcadena=''
[String]$cadenaconvert=''

do
{
$cadena=$rec.Recognize().Text
$cadenaconvert=[String]$cadena.ToString()
$cadenaconvert
}while($rec.AudioFormat)
```

---------------------

# Otros enlaces interesantes

## Expresiones regulares
https://www.regular-expressions.info/tutorial.html
http://www.vicente-navarro.com/blog/2007/04/13/expresiones-regulares-en-la-shell-ejemplos-de-uso-con-grep-awk-y-sed/

## DEJAVU: AUDIO FINGERPRINTING AND RECOGNITION IN PYTHON
https://www.jesusninoc.com/02/06/dejavu-audio-fingerprinting-and-recognition-in-python/

## Número de hilos que ejecuta Icecast
https://github.com/jesnino/Bash/blob/master/Procesos/EjerciciosHilos.sh

## Simular la transmisión de vídeo entre un cliente y un servidor (streaming)
https://www.jesusninoc.com/2016/03/12/simular-la-transmision-de-video-entre-un-cliente-y-un-servidor-streaming/

## Enviar un vídeo MP4 entre dos Linux mediante Netcat
https://www.jesusninoc.com/2017/11/12/enviar-un-video-mp4-entre-dos-linux-mediante-netcat/

## Livestreamer is a command-line utility that pipes video streams from various services into a video player, such as VLC
https://www.jesusninoc.com/2017/10/07/livestreamer/

## Conectarse por SSH al router de fibra óptica MitraStar de Movistar desde PowerShell
https://www.jesusninoc.com/2017/11/16/conectarse-por-ssh-al-router-de-fibra-optica-mitrastar-de-movistar-desde-powershell/

## Ver los procesos que se están ejecutando en el router de fibra óptica MitraStar de Movistar desde PowerShell
https://www.jesusninoc.com/2017/11/17/ver-los-procesos-que-se-estan-ejecutando-en-el-router-de-fibra-optica-mitrastar-de-movistar-desde-powershell/

## Autenticarse en un router de fibra óptica MitraStar de Movistar y ver una lista de llamadas perdidas
https://www.jesusninoc.com/2017/04/10/autenticarse-en-un-router-de-fibra-optica-mitrastar-de-movistar-y-ver-una-lista-de-llamadas-perdidas/

## Autenticarse en un router de fibra óptica MitraStar de Movistar y ver las reglas del firewall
https://www.jesusninoc.com/2017/04/13/autenticarse-en-un-router-de-fibra-optica-mitrastar-de-movistar-y-ver-las-reglas-del-firewall/

## Autenticarse en un router de fibra óptica MitraStar de Movistar y ver las asignaciones DHCP
https://www.jesusninoc.com/2017/05/14/autenticarse-en-un-router-de-fibra-optica-mitrastar-de-movistar-y-ver-las-asignaciones-dhcp/

## Autenticarse en un router de fibra óptica MitraStar de Movistar y ver la tabla ARP
https://www.jesusninoc.com/2017/05/10/autenticarse-en-un-router-de-fibra-optica-mitrastar-de-movistar-y-ver-la-tabla-arp/

-----------------

# Clase especial

## REPRODUCIR TRÁILERES DE PELÍCULAS
* https://www.jesusninoc.com/11/21/reproducir-traileres-de-peliculas/

## ENVIAR LA REPRODUCCIÓN DE LOS TRÁILERES DE PELÍCULAS A LA SMART TV
* https://www.jesusninoc.com/11/22/enviar-la-reproduccion-de-los-traileres-de-peliculas-a-la-smart-tv/

-----------------

# Clase especial

## Crear un audio que vamos a mandar mediante señales de radio

```PowerShell
#Convertir una frase en audio con la voz del sistema operativo desde PowerShell

Add-Type -AssemblyName System.Speech
$synthesizer = New-Object -TypeName System.Speech.Synthesis.SpeechSynthesizer
$synthesizer.SetOutputToWaveFile("saludo.wav")
$synthesizer.Speak("Hola amigo Pedro")
$synthesizer.SetOutputToDefaultAudioDevice()
Get-ChildItem .\saludo.wav
```

## Subir el audio a Raspberry Pi realizando una conexión SCP
```PowerShell
#Iniciar una sesión SCP
#Para iniciar sesión SSH es necesario indicar la dirección IP del equipo al que nos vamos a conectar y también hay que introducir los credenciales (usuario y contraseña).

$Pass = ConvertTo-SecureString -String "raspberry" -AsPlainText -Force
$Credential = New-Object -TypeName "System.Management.Automation.PSCredential" -ArgumentList "pi", $Pass

#Para configurar Set-SCPFile
#Indicar el fichero que vamos a subir -LocalFile
#Indicar el equipo al que nos vamos a conectar -ComputerName
#Indicar la ruta en la que vamos a subir el audio -RemotePath
#Forzar la conexión para evitar fallo "Key exchange negotiation failed."
#Indicar los credenciales que hemos creado anteriormente

Set-SCPFile -LocalFile .\saludo.wav -ComputerName 192.168.1.161 -RemotePath ./fmm/fm_transmitter-master -Force -Credential $Credential
```

-----------------

# Más clases especiales
* https://www.jesusninoc.com/02/16/muneco-bailando/
* https://github.com/jesusninoc/ClasesIAW/blob/master/2019-11-25.md#proyectos-de-la-semana
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-01-01.md

--------------
--------------

# Examen de ISO

## Función que crear una estructura de directorios sobre la información que hay de servicios, procesos e hilos
## Copia de seguridad (realizar una función)
