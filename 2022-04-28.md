# Supervisión del rendimiento del sistema:
- Herramientas de monitorización en tiempo real.
- Herramientas de monitorización continuada.
- Herramientas de análisis del rendimiento.
- Tipos de sucesos: sucesos del sistema, sucesos de seguridad, sucesos de aplicaciones, etc.
- Registros de sucesos.
- Monitorización de sucesos.
- Gestión de aplicaciones, procesos y subprocesos.
- Monitorización de aplicaciones y procesos.
- Monitorización del rendimiento:
  - Monitor del sistema: histogramas, gráficos e informes.
  - Contadores y registros de seguimiento.
  - Programas acciones mediante las alertas. 

# Introducción

## 10. Gestión del rendimiento en PowerShell
https://www.jesusninoc.com/2017/07/10/10-gestion-del-rendimiento-en-powershell/

- Monitorización
- Rendimiento
- Registros del sistema
- Reparación
- Copias de seguridad
- Restauración

## Encontrarse a uno mismo
```PowerShell
Get-EventLog Security | Where-Object Message -Match "asir1joselui"
```

## Ejemplos de introducción a monitorizar
```PowerShell
# (INCORRECTO) Intentar relacionar los procesos con los programas que se arrancan al inicio del arranque del sistema operativo 
Get-CimInstance -ClassName Win32_StartupCommand  | select Caption, @{n='NombreP';e={(Get-Process -name $_.Caption | Select Name).name}}

# Comprobar que se está ejecutando un programa que se arranca al inicio del arranque del sistema operativo
Get-Process -Name MSOSYNC

# (CORRECTO 1) # Intentar relacionar los procesos con los programas que se arrancan al inicio del arranque del sistema operativo 
$acumul = Get-CimInstance -ClassName Win32_StartupCommand | select Command | %{
    
        $temperal = $_.Command.tolower().replace(".exe","€").split("€")[0].split("\")

        $temperal[$temperal.Count-1]

}

Get-Process -Name $acumul

# (CORRECTO 2) # Intentar relacionar los procesos con los programas que se arrancan al inicio del arranque del sistema operativo 
function comprobar($programa){
    Get-Process -Name $programa -ErrorAction Ignore
}

Get-CimInstance -ClassName Win32_StartupCommand | select Command | %{
    
        $temperal = $_.Command.tolower().replace(".exe","€").split("€")[0].split("\")

        comprobar $temperal[$temperal.Count-1]

}

# (CORRECTO 3) # Intentar relacionar los procesos con los programas que se arrancan al inicio del arranque del sistema operativo 
$acumul = Get-CimInstance -ClassName Win32_StartupCommand | select Command | %{
    
        $temperal = $_.Command.tolower().replace(".exe","€").split("€")[0].split("\")

        $temperal[$temperal.Count-1]

}

$acumul | %{
    $_
    ((Get-Process).name.toupper()).contains($_.toupper())
}
```

## Ejercicio: registrar un evento cuando se logre realizar una conexión entre un cliente y un servidor mediante UDP (almacenar la dirección IP de la conexión del cliente o del servidor)
* https://www.jesusninoc.com/05/08/ejercicios-de-powershell-registrar-un-evento-cuando-se-logre-realizar-una-conexion-entre-un-cliente-y-un-servidor-mediante-udp-almacenar-la-direccion-ip-de-la-conexion-del-cliente-o-del-servidor/

### Solución (otra forma de verlo, el cliente manda crear un log al servidor)

#### Cliente
```PowerShell
##Client
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]"192.168.43.61",$port)
$udpclient=new-Object System.Net.Sockets.UdpClient
$b=[Text.Encoding]::ASCII.GetBytes('Write-EventLog -LogName "Application" -Source "Microsoft-Windows-User-Loader" -EventID 916 -EntryType Information -Message "192.168.43.108" -Category 2 -RawData 10,20')
$bytesSent=$udpclient.Send($b,$b.length,$endpoint)
$udpclient.Close()
```
#### Servidor
```PowerShell
##Server
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Any,$port)
$udpclient=new-Object System.Net.Sockets.UdpClient $port
$content=$udpclient.Receive([ref]$endpoint)
$udpclient.Close()
Invoke-Expression ([Text.Encoding]::ASCII.GetString($content))
```

-------------------
-------------------

# Supervisión del rendimiento del sistema:
- Herramientas de monitorización en tiempo real.
- Herramientas de monitorización continuada.
- Herramientas de análisis del rendimiento.
- Tipos de sucesos: sucesos del sistema, sucesos de seguridad, sucesos de aplicaciones, etc.
- Registros de sucesos.
- Monitorización de sucesos.
- Gestión de aplicaciones, procesos y subprocesos.
- Monitorización de aplicaciones y procesos.
- Monitorización del rendimiento:
  - Monitor del sistema: histogramas, gráficos e informes.
  - Contadores y registros de seguimiento.
  - Programas acciones mediante las alertas. 

--------------------

# Monitorizar procesos
## 7. Gestión de procesos en PowerShell
https://www.jesusninoc.com/2017/07/07/7-gestion-de-procesos-en-powershell/

## System Monitor
System Monitor (Sysmon) is a Windows system service and device driver that, once installed on a system, remains resident across system reboots to monitor and log system activity to the Windows event log. It provides detailed information about process creations, network connections, and changes to file creation time. By collecting the events it generates using Windows Event Collection or SIEM agents and subsequently analyzing them, you can identify malicious or anomalous activity and understand how intruders and malware operate on your network.
* https://www.fwhibbit.es/sysmon-el-gran-hermano-de-windows-y-el-super-sysmonview

Install with default settings (process images hashed with sha1 and no network monitoring)
```MD-DOS
sysmon -accepteula –i
```
Install with md5 and sha256 hashing of process created and monitoring network connections
```MD-DOS
sysmon -accepteula –i –h md5,sha256 –n
```
Install Sysmon with a configuration file (as described below)
```MD-DOS
sysmon –accepteula –i c:\windows\config.xml
```
Uninstall
```MD-DOS
sysmon –u
```
Dump the current configuration
```MD-DOS
sysmon –c
```
Change the configuration to use all hashes, no network monitoring and monitoring of DLLs in Lsass
```MD-DOS
sysmon –c –h * –l lsass.exe
```
Change the configuration of sysmon with a configuration file (as described below)
```MD-DOS
sysmon –c c:\windows\config.xml
```
Change the configuration to default settings
```MD-DOS
sysmon –c --
```
Show the configuration schema
```MD-DOS
sysmon -s
```

## Sources, configuration and how to detect evil things utilizing Microsoft Sysmon
https://github.com/MHaggis/sysmon-dfir

--------------
--------------

# Supervisión del rendimiento del sistema:
- Herramientas de monitorización en tiempo real.
- Herramientas de monitorización continuada.
- Herramientas de análisis del rendimiento.
- Tipos de sucesos: sucesos del sistema, sucesos de seguridad, sucesos de aplicaciones, etc.
- Registros de sucesos.
- Monitorización de sucesos.
- Gestión de aplicaciones, procesos y subprocesos.
- Monitorización de aplicaciones y procesos.
- Monitorización del rendimiento:
  - Monitor del sistema: histogramas, gráficos e informes.
  - Contadores y registros de seguimiento.
  - Programas acciones mediante las alertas. 

--------------

# Logs

## Logs en Windows

### PowerShell
https://www.jesusninoc.com/2017/07/10/10-gestion-del-rendimiento-en-powershell/

### List event log
https://www.jesusninoc.com/2018/03/27/list-event-log

### Write-EventLog
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/write-eventlog?view=powershell-5.1

### Escribir y ver un evento en el registro de eventos de aplicación
https://www.jesusninoc.com/2018/05/04/escribir-y-ver-un-evento-en-el-registro-de-eventos-de-aplicacion/

### Almacenar información convertida a byte en un evento en el registro de eventos de aplicación
https://www.jesusninoc.com/2018/05/05/almacenar-informacion-convertida-a-byte-en-un-evento-en-el-registro-de-eventos-de-aplicacion/

### Ejecutar la información que se encuentra en un evento en el registro de eventos de aplicación
https://www.jesusninoc.com/2018/05/06/ejecutar-la-informacion-que-se-encuentra-en-un-evento-en-el-registro-de-eventos-de-aplicacion/

### Windows Event Log to the Dark Side — Storing Payloads and Configurations
https://medium.com/@5yx/windows-event-log-to-the-dark-side-storing-payloads-and-configurations-9c8ad92637f2

### Active Directory: Configuring Event Log Subscriptions (Forwarding)
https://sid-500.com/2018/04/23/active-directory-configuring-event-log-subscriptions-forwarding/

### HOW TO DETECT PASS-THE-HASH ATTACKS
https://blog.stealthbits.com/how-to-detect-pass-the-hash-attacks/

## Logs en Linux
https://github.com/jesusninoc/ClasesISO/blob/master/2018-05-13.md#registros-de-sucesos

```Bash
cd /var/log
ls
```

- /var/log/message: registro de mensajes generales del sistema
- /var/log/auth.log: log de autenticación
- /var/log/kern.log: registro del kernel
- /var/log/cron.log: registro de cron
- /var/log/maillog: registro del servidor de mails
- /var/log/qmail/ : registro de Qmail
- /var/log/httpd/: registro de errores y accesos a Apache
- /var/log/lighttpd: registro de errores y accesos a Lighttpd
- /var/log/boot.log : registro de inicio del sistema
- /var/log/mysqld.log: registro de la base de datos MySQL
- /var/log/secure: log de autenticación
- /var/log/utmp or /var/log/wtmp : registro de logins

### Analizar logs en Linux
#### Regular Expressions
```Bash
 grep -a "user juanito" /var/log/auth.log
```
#### Tail
```Bash
$ tail -f /var/log/auth.log | grep -a 'invalid'
```
#### Cut
```Bash
grep "authentication failure" /var/log/auth.log | cut -d '=' -f 8
```
#### Awk
```Bash
awk '/sshd.*invalid user/ { print $9 }' /var/log/auth.log
```

-------------
-------------

# Supervisión del rendimiento del sistema:
- Herramientas de monitorización en tiempo real.
- Herramientas de monitorización continuada.
- Herramientas de análisis del rendimiento.
- Tipos de sucesos: sucesos del sistema, sucesos de seguridad, sucesos de aplicaciones, etc.
- Registros de sucesos.
- Monitorización de sucesos.
- Gestión de aplicaciones, procesos y subprocesos.
- Monitorización de aplicaciones y procesos.
- Monitorización del rendimiento:
  - Monitor del sistema: histogramas, gráficos e informes.
  - Contadores y registros de seguimiento.
  - Programas acciones mediante las alertas. 

--------------

# Monitorizar servicios
## Analizar servicios con PowerShell
https://www.jesusninoc.com/2016/11/10/analizar-servicios-con-powershell/

---------
---------

# Supervisión del rendimiento del sistema:
- Herramientas de monitorización en tiempo real.
- Herramientas de monitorización continuada.
- Herramientas de análisis del rendimiento.
- Tipos de sucesos: sucesos del sistema, sucesos de seguridad, sucesos de aplicaciones, etc.
- Registros de sucesos.
- Monitorización de sucesos.
- Gestión de aplicaciones, procesos y subprocesos.
- Monitorización de aplicaciones y procesos.
- Monitorización del rendimiento:
  - Monitor del sistema: histogramas, gráficos e informes.
  - Contadores y registros de seguimiento.
  - Programas acciones mediante las alertas. 

--------------

# DLL
* Run PowerShell with rundll32. Bypass software restrictions https://github.com/p3nt4/PowerShdll
* https://github.com/jesusninoc/ClasesISO/blob/master/2018-04-13.md
* https://www.jesusninoc.com/2018/04/15/ejecutar-microsoft-coff-binary-file-dumper-dumpbin-exe-desde-powershell/

## Ejercicios de PowerShell: ver si zipfldr.dll se está ejecutando en el sistema
* https://www.jesusninoc.com/05/13/ejercicios-de-powershell-ver-si-un-fichero-dll-se-esta-utilizando-en-la-ejecucion-de-algun-proceso/

--------------------

# Integridad
## Comprobar si ha cambiado algún fichero utilizando la función hash SHA1
https://www.jesusninoc.com/2016/01/27/comprobar-si-ha-cambiado-algun-fichero-utilizando-la-funcion-hash-sha1/

## Ejercicio
### Detectar que ha cambiado una dll analizando el DNS
```PowerShell
# Buscar resolución en DNS
"jesusninoc.com/wmi.dll" > captura.log

gc .\captura.log | %{
        if ($_ -match "dll")
        {
            $_.split("/")[1]
        }
    }


# Localizar la posición de la dll en un listado de dll's
(gc .\posciones.txt)[(gc .\posciones.txt).IndexOf("luis")]
```

--------------------

# WMIC

## Listar actualizaciones y almacenar en un fichero html
```MS-DOS
wmic qfe list full /format:htable > hotfixes.htm
```

## Examples of WMIC commands for Windows .NET SERVER Family 
https://www.cs.cmu.edu/~tgp/scsadmins/winadmin/WMIC_Queries.txt

## Enable RDP remotely via #wmic on #Windows 2008 and above: 
```MS-DOS
wmic /namespace:\\root\CIMV2\TerminalServices PATH Win32_TerminalServiceSetting WHERE (__CLASS !="") CALL SetAllowTSConnections 1
```

## WMIC.EXE Whitelisting Bypass - Hacking with Style, Stylesheets
https://subt0x11.blogspot.com.es/2018/04/wmicexe-whitelisting-bypass-hacking.html

## Living Off The Land Binaries And Scripts - (LOLBins and LOLScripts)
https://github.com/api0cradle/LOLBAS

## GTFOBins
GTFOBins is a curated list of Unix binaries that can be exploited by an attacker to bypass local security restrictions.
https://gtfobins.github.io/

--------------------

# Analizar datos en memoria

## Leer el contenido de un fichero en ASCII y representarlo en decimal
http://www.jesusninoc.com/2017/01/29/leer-el-contenido-de-un-fichero-en-ascii-y-representarlo-en-decimal/

## Crear un fichero de volcado de memoria de un proceso
http://www.jesusninoc.com/2016/03/04/crear-un-fichero-de-volcado-de-memoria-de-un-proceso/

## Buscar una cadena dentro de un fichero de volcado de memoria
http://www.jesusninoc.com/2016/03/13/buscar-una-cadena-dentro-de-un-fichero-de-volcado-de-memoria/

--------------------

# Red

## Enabling DNS Logging for Windows Server 2012
http://support.moonpoint.com/network/dns/windows/logging/srvr2012.php

## Mostrar información sobre las reglas del Firewall de Windows con PowerShell
```PowerShell
$f = New-object -comObject HNetCfg.FwPolicy2
$f.Rules | Select-Object name,applicationname,localports,remoteports | Out-GridView
```

## Display list of blocked ports
```PowerShell
$f = New-object -comObject HNetCfg.FwPolicy2
$f.rules |  where {$_.action -eq "0"} | select name,applicationname,localports
```

## Modificar datagramas UDP con SoftPerfect Network Protocol Analyzer
https://www.jesusninoc.com/2016/03/19/modificar-datagramas-udp-con-softperfect-network-protocol-analyzer/

## Building My Ideal Router For $50
https://blog.tjll.net/building-my-perfect-router/

## Automatizar con WinSCP
### Parameters for winscp.exe executable:
https://winscp.net/eng/docs/commandline

## Analizar datos en red
### La captura de tráfico 
http://www.elladodelmal.com/2018/03/amazon-dash-button-un-hack-para-enviar.html

## Compilation of commands, tips and scripts that helped me throughout Vulnhub, Hackthebox, OSCP and real scenarios
https://github.com/adon90/pentest_compilation

## Ejercicios sobre redes
- Detectar en la red el fabricante del gateway
  - https://www.jesusninoc.com/05/13/ejercicios-de-powershell-conocer-el-fabricante-del-dispositivo-gateway-de-nuestra-red/
- Detectar en red dispositivos
```PowerShell
(Get-NetNeighbor | Where-Object {$_.IPAddress -match "192.168"}).IPAddress
```
- Conexión entre alumnos para detectar dispositivos
- Conectarse utilizando protocolos de capa Aplicacion (SSH)
- Comprobar integridad de ficheros en carpetas remotas
- Carpetas compartidas con permisos
  - https://www.jesusninoc.com/2015/08/19/anadir-permiso-ntfs-a-una-carpeta/
- Conexión con sockets en Linux
  - https://github.com/jesusninoc/ClasesSeguridad/blob/master/2018-02-21.md
- Conexión con sockets en PowerShell
  - https://www.jesusninoc.com/2017/01/27/ejecutar-un-cmdlet-remotamente-en-un-equipo-utilizando-sockets-udp/
- Analizar el tráfico por red:
  - https://hackertarget.com/tshark-tutorial-and-filter-examples/
```MS-DOS
tshark -R "ip.addr == 192.168.0.1" -w f:\power\capture.cap
```
- Tcpdump Examples
  - https://hackertarget.com/tcpdump-examples/
- ¿Qué estoy imprimiendo?
- Crear un iventario de lo que tiene un equipo (conectar a varios equipos) y guardar la información en una carpeta compartida
```PowerShell
#Llamadas WMI
$ComputerSystem=Get-WmiObject Win32_ComputerSystem
$BaseBoard=Get-WmiObject Win32_BaseBoard
$BIOS=Get-WmiObject Win32_BIOS
$Processor=Get-WmiObject Win32_Processor
$Battery=Get-WmiObject Win32_Battery
 
#Crear un objeto con todos los datos sobre el hardware
[PSCustomObject]@{
 Model = $ComputerSystem.Model
 ManufacturerBoard = $BaseBoard.Manufacturer
 BIOSVersion = $BIOS.SMbiosbiosversion
 BIOSSerialNumber = $BIOS.serialnumber
 ManufacturerProcessor=$Processor.Manufacturer
 MaxClockSpeed=$Processor.MaxClockSpeed
 DeviceIDBattery=$Battery.DeviceID.trim()
}
```
- Analizar las conexiones abiertas en un equipo
- Fuerza bruta
  - https://github.com/jesusninoc/ClasesISO/blob/master/2018-04-17.md#simular-una-fuerza-bruta-mediante-peticiones-http-desde-powershell-utilizando-el-m%C3%A9todo-get
- Analizar conexiones de red analizando el tráfico de red y relacionarlo con hilos, procesos y servicios
```PowerShell
cd "C:\Program Files\Wireshark\"
tshark -r capture.pcap -Y "udp or tcp"
gc .\todo.txt |%{ $_}
```
```PowerShell
Get-NetTCPConnection | Where-Object {$_.RemotePort -eq $_.split(" ")[5]}
```
```PowerShell
Get-NetTCPConnection | select OwningProcess | %{Get-Process -id $_.OwningProcess}
```
```PowerShell
netstat -ano
```
- Mostrar los hilos que se están ejecutando en relación con los servicios y los procesos
  - https://www.jesusninoc.com/2015/10/28/mostrar-los-hilos-que-se-estan-ejecutando-en-relacion-con-los-servicios-y-los-procesos/
- Mostrar los hilos que se están ejecutando en relación con los servicios, los procesos y los puertos abiertos TCP
  - https://www.jesusninoc.com/2017/04/04/mostrar-los-hilos-que-se-estan-ejecutando-en-relacion-con-los-servicios-los-procesos-y-los-puertos-abiertos-tcp/
- Mostrar los hilos que se están ejecutando en relación con los servicios, los procesos y los puertos abiertos UDP
  - https://www.jesusninoc.com/2017/03/11/mostrar-los-hilos-que-se-estan-ejecutando-en-relacion-con-los-servicios-los-procesos-y-los-puertos-abiertos-udp/
- Buscar direcciones IP en la red local y realizar una consulta DNS
```PowerShell
(Get-NetNeighbor).IPAddress | Select-String "192.168.1." | % {
Resolve-DnsName $_
}
```
- Resolver la siguiente situación
  - https://github.com/jesusninoc/ClasesSeguridad/blob/master/2018-02-14.md
- Analizar DLL en un equipo remoto
  - https://www.jesusninoc.com/04/19/listar-funciones-exportadas-de-un-archivo-dll-con-dumpbin-desde-powershell/

-----------------

## Packet capture on Windows without a kernel driver
https://github.com/nospaceships/raw-socket-sniffer

## Relación entre puertos UDP y procesos (construir un objeto con propiedades personalizadas)
https://www.jesusninoc.com/2018/05/02/relacion-entre-puertos-udp-y-procesos-construir-un-objeto-con-propiedades-personalizadas/

## Relación entre puertos TCP y procesos (construir un objeto con propiedades personalizadas)
https://www.jesusninoc.com/2018/05/03/relacion-entre-puertos-tcp-y-procesos-construir-un-objeto-con-propiedades-personalizadas/

## Conectarse a una carpeta compartida con PowerShell
https://www.jesusninoc.com/2017/06/14/conectarse-a-una-carpeta-compartida-con-powershell/

## Instalar remotamente un paquete MSI
https://www.jesusninoc.com/2017/05/27/instalar-remotamente-un-paquete-msi/

## Enabling Remoting
There are many ways how cmdlets can get remote information from another computer. Here are just a few:

```PowerShell
# try and connect to this computer
# (adjust it to a valid name in your network) 
$destinationServer = "SERVER12"
 
# PowerShell remoting 
$result1 = Invoke-Command { Get-Service } -ComputerName $destinationServer
 
# built-in 
$result2 = Get-Service -ComputerName $destinationServer
$result3 = Get-Process -ComputerName $destinationServer
```

If you’d like to open up the most commonly used remoting techniques on a test machine, run these lines from a PowerShell with elevated privileges:

```PowerShell
netsh firewall set service remoteadmin enable 
Enable-PSRemoting -SkipNetworkProfileCheck -Force
```
## Lateral Movement Using WinRM and WMI
https://redcanary.com/blog/lateral-movement-winrm-wmi/

## NO WIN32_PROCESS NEEDED – EXPANDING THE WMI LATERAL MOVEMENT ARSENAL
https://www.cybereason.com/blog/wmi-lateral-movement-win32

## Get-WmiObject
http://community.idera.com/powershell/powertips/b/tips/posts/wmi-quick-primer-part-2

Here are two example calls that both retrieve information about file shares from a remote system (make sure you adjust the computer name):
```PowerShell
Get-WmiObject -Class Win32_Share -ComputerName sr0710 
Get-CimInstance -ClassName Win32_Share -ComputerName sr0710
```

## Get-CimInstance
While Get-WmiObject always uses DCOM as a transport protocol, Get-CimInstance uses WSMan (a webservice-type of communication). Most modern Windows systems support WSMan, but if you need to contact older servers, they may only respond to DCOM, thus Get-CimInstance may fail.

Get-CimInstance can use session options, however, that provide great flexibility, and allow you to choose the transport protocol. In order to use DCOM (just like Get-WmiObject), do the following:

```PowerShell
$options = New-CimSessionOption -Protocol Dcom 
$session = New-CimSession -ComputerName sr0710 -SessionOption $options
$sh = Get-CimInstance -ClassName Win32_Share -CimSession $session 
Remove-CimSession -CimSession $session
```

Here is an example illustrating how the same session is used for two queries:
http://community.idera.com/powershell/powertips/b/tips/posts/wmi-quick-primer-part-3
```PowerShell
# create the session 
$options = New-CimSessionOption -Protocol Wsman 
$session = New-CimSession -ComputerName sr0710 -SessionOption $options
 
# reuse the session for as many queries as you like 
$sh = Get-CimInstance -ClassName Win32_Share -CimSession $session -Filter 'Name="Admin$"' 
$se = Get-CimInstance -ClassName Win32_Service -CimSession $session
 
# remove the session at the end 
Remove-CimSession -CimSession $session
```

## Packet generator
A packet generator or packet builder is a type of software that generates random packets or allows the user to construct detailed custom packets. Depending on the network medium and operating system, packet generators utilize raw sockets, NDIS function calls, or direct access to the network adapter kernel-mode driver.

|Title|Author|OS|Interface|License|
|---|---|---|---|---|
AnetTest|Anton aka kronos256|Windows, Unix|CLI|GPL
Bit-Twist|Addy Yeow Chin Heng|Windows, Linux, BSD, Mac OS X|CLI|GPLv2
Cat Karat packet builder|Valery Diomin, Yakov Tetruashvili|Windows|GUI|Packet Builder License
Colasoft Packet Builder|Colasoft|Windows|GUI|Packet Builder License: Freeware
CommView Packet Generator |TamoSoft|Windows|GUI|Proprietary EULA
IP Sorcery|Josiah Zayner|Unix|CLI and GUI|GPL
Nemesis|Jeff Nathan|Windows, Unix|CLI|BSD
Ostinato|Srivats P|Windows, Linux, BSD, Mac OS X|GUI and API|GPLv3
Packet Construction Set|George Neville-Neil|Linux, BSD, Mac OS X|CLI|BSD-like
Packet Sender|Dan Nagle|Windows, Linux, Mac OS X|CLI and GUI|GPLv2
Pktgen|Linux Foundation|Linux|CLI|GPLv2
packETH|Miha Jemec aka jemcek|Linux, Windows|GUI|GPLv2
pierf|Pieter Blommaert|Windows(Cygwin)/Linux|CLI|free BSD
rain|Michael Behan|Linux, BSD|CLI|free GPLv2
Scapy|Philippe BIONDI|Linux/Unix/Windows|CLI|GPLv2
targa3|Mixter|Linux, Unix|CLI|?
UMPA|Adriano Monteiro Marques|Cross-platform (Python)|?|GPLv2
trafgen|Daniel Borkmann|Linux|CLI|GPLv2
xcap|cxxxap|Windows|GUI|Free
Simple Packet Sender (SPS)|h0h1r4um|Linux|GUI|GPLv3
WARP17|Juniper Networks|Linux|CLI and API|BSD
Wirefloss|Wirefloss|Web page|GUI|Free

## Modificar paquetes
### Modificar la dirección IP de origen en mensajes UDP con SoftPerfect Network Protocol Analyzer
https://www.jesusninoc.com/2016/04/02/modificar-la-direccion-ip-de-origen-en-mensajes-udp-con-softperfect-network-protocol-analyzer/
### Modificar datagramas UDP con SoftPerfect Network Protocol Analyzer
https://www.jesusninoc.com/2016/03/19/modificar-datagramas-udp-con-softperfect-network-protocol-analyzer/
### Polymorph: Modificando paquetes de red en tiempo real. Inyectando JavaScript en peticiones HTTP
http://www.elladodelmal.com/2018/04/polymorph-modificando-paquetes-de-red.html
http://www.elladodelmal.com/2018/04/polymorph-modificando-paquetes-de-red_30.html
http://www.elladodelmal.com/2018/05/polymorph-modificando-paquetes-de-red.html

## Archivos sin conexión
https://answers.microsoft.com/es-es/windows/forum/windows_10-files/archivos-de-red-sin-conexi%C3%B3n-win10-pro/db125e74-b42a-4fac-948f-4b66bbd00a12

## VPN
### Always On VPN Windows 10 Device Tunnel Step-by-Step Configuration using PowerShell
https://directaccess.richardhicks.com/2017/12/11/always-on-vpn-windows-10-device-tunnel-step-by-step-configuration-using-powershell/

### Dis root
https://disroot.org/en

## Security
### Get things from one computer to another, safely
This package provides a library and a command-line tool named wormhole, which makes it possible to get arbitrary-sized files and directories (or short pieces of text) from one computer to another. The two endpoints are identified by using identical "wormhole codes": in general, the sending machine generates and displays the code, which must then be typed into the receiving machine.
* https://github.com/warner/magic-wormhole
* https://magic-wormhole.readthedocs.io/en/latest/welcome.html#example

### Ejecutar un cmdlet remotamente en un equipo utilizando sockets UDP
https://www.jesusninoc.com/2017/01/27/ejecutar-un-cmdlet-remotamente-en-un-equipo-utilizando-sockets-udp/

--------------------

# PCAP (container of PCAP captures mapped to the relevant attack tactic)
* https://github.com/sbousseaden/PCAP-ATTACK

--------------------

# USB
## USBPcap – USB Packet capture for Windows
https://www.jesusninoc.com/2016/05/01/usbpcap-usb-packet-capture-for-windows/
## Wireshark and USB
https://isc.sans.edu/forums/diary/Wireshark+and+USB/23457/
## Hackers exploit casino's smart thermometer to steal database info
https://mashable.com/2018/04/15/casino-smart-thermometer-hacked/
## Logran robar datos de un ordenador a través del cableado eléctrico
https://www.redeszone.net/2018/04/13/logran-robar-datos-ordenador-traves-del-cableado-electrico/

----------
----------

# Resolución de incidencias y asistencia técnica:
- Interpretación, análisis y elaboración de documentación técnica.
- Interpretación, análisis y elaboración de manuales de instalación y configuración de sistemas operativos y aplicaciones.
- Licencias de cliente y licencias de servidor.
- Control de versiones y licencias.
- Instalaciones desatendidas.
- Implementación de ficheros de respuestas.
- Servidores de actualizaciones automáticas.
- Asistencia remota.
- Partes de incidencias.
- Protocolos de actuación.
- Administración remota.

# Rendimiento del hardware
* https://www.jesusninoc.com/02/27/obtener-un-informe-detallado-del-consumo-de-la-bateria-en-windows-desde-powershell/

---------------------------

# Trabajo para matrícula
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-05-28.md

# Introducción al futuro (teniendo en cuenta)
* https://www.jesusninoc.com/05/02/chuleta-resumen-de-operaciones-en-el-sistema-operativo-con-archivos-y-directorios-en-modo-texto-comandos-en-linux-y-windows-y-cmdlets-en-powershell-y-modo-grafico/
* https://www.jesusninoc.com/05/03/chuleta-resumen-de-tareas-de-administracion-en-el-sistema-operativo-en-modo-texto-comandos-en-linux-y-windows-y-cmdlets-en-powershell-y-modo-grafico/
* https://zentyal.com/wp-content/themes/storefront-zentyal-child/assets/files/sample_chapter_zentyal_vpn_openvpn_es.pdf
* https://github.com/jesusninoc/ClasesASO
* https://github.com/jesusninoc/ClasesIAW
* https://github.com/jesusninoc/ClasesSAD

----------
----------

# Examen liberatorio

## Opción 1

### El departamento de recursos humanos envía el siguiente fichero...
```
nombre;apellido;password;grupo;ou;appbloqueada
juan;sinmiedo;P@ss1wordA;asir;asir;notepad
laura;valiente;P@ss1wordA;af;af;mspaint
```

#### - Nivel 1: crear un script que permita realizar todas las tareas que aparecen en el fichero.
#### - Nivel 2: crear un script que permita realizar las operaciones de forma ordenada.
#### - Nivel 3: crear un script que permita realizar las operaciones utilizando UDP.

## Opción 2

### Crear la estructura de red del Centro leyendo de un fichero, teniendo en cuenta:
- Hay seis grupos de clases, seis unidades organizativas
- Hay que crear usuarios y grupos para cada clase
- Hay que deshabilitar usuarios y moverlos a la unidad organizativa de los deshabilitados
- Borrar unidades organizativas
- Crear una carpeta para cada usuario

---------
---------

# Resolución de incidencias y asistencia técnica:
- Interpretación, análisis y elaboración de documentación técnica.
- Interpretación, análisis y elaboración de manuales de instalación y configuración de sistemas operativos y aplicaciones.
- Licencias de cliente y licencias de servidor.
- Control de versiones y licencias.
- Instalaciones desatendidas.
- Implementación de ficheros de respuestas.
- Servidores de actualizaciones automáticas.
- Asistencia remota.
- Partes de incidencias.
- Protocolos de actuación.
- Administración remota.

# Casos de introducción
## - Preparar un equipo
* https://www.jesusninoc.com/04/22/instalacion-de-sistemas-operativos/
## - Analizar licencias
* https://www.jesusninoc.com/12/02/obtener-serial-de-windows-con-powershell/
## - Administración remota
* https://github.com/jesusninoc/ClasesSeguridad/blob/master/2019-01-16.md
## - Inventario
* https://www.jesusninoc.com/09/07/obtener-informacion-sobre-el-hardware-creando-un-objeto-con-todos-los-datos/
## - Reemplazar espacios en fichero JPG
## - Detectar un problema de red
## - Detectar en los logs que hay intentos de obtener el fichero passwd
* https://www.jesusninoc.com/05/08/consulta-para-ver-intentos-de-obtener-el-fichero-passwd/
### Solución con una query
```PowerShell
.\LogParser.exe "SELECT * FROM 'C:\xampp\apache\logs\access.log' where text like '%passwd%'"
```

------------
------------

# Trabajo para optar al 10 y a MH
### Utilizando sockets comunicar un cliente con un servidor y aplicar el mayor número de conceptos vistos durante el curso:
- Crear una herramienta de control remoto.
- Controlar y gestionar el uso del hardware del ordenador.
- Administrar la ejecución de los procesos.
- Controlar el acceso de los programas o los usuarios a los recursos del sistema.
- Particionado del disco duro.
- Registros (logs) del sistema.
- Configuración del protocolo TCP/IP en un cliente de red.
- Configuración de la resolución de nombres.
- Ficheros de configuración de red.
- Gestión de sistemas de archivos.
- Permisos locales de acceso a ficheros y directorios.
- Planes de copias de seguridad y restablecimiento.
- Compresión de datos.
- Permisos de red. Permisos locales.
- Registros de sucesos.
- Monitorización de sucesos.

--------------

## Ayuda
### Realizar conexiones TCP/UDP con Powershell
https://www.jesusninoc.com/2015/11/10/realizar-conexiones-tcp-udp-con-powershell/

### Ejecutar un cmdlet remotamente en un equipo utilizando sockets UDP
https://www.jesusninoc.com/2017/01/27/ejecutar-un-cmdlet-remotamente-en-un-equipo-utilizando-sockets-udp/

## Ayuda avanzada
### Pedir el nombre de un proceso y mostrar información del proceso mediante PowerShell con Node-PowerShell, EJS (Embedded JavaScript), Body-parser y Express
https://www.jesusninoc.com/2018/06/10/pedir-el-nombre-de-un-proceso-y-mostrar-informacion-del-proceso-mediante-powershell-con-node-powershell-ejs-body-parser-y-express-node-js/

### Build a Weather Website in 30 minutes with Node.js + Express + OpenWeather
https://codeburst.io/build-a-weather-website-in-30-minutes-with-node-js-express-openweather-a317f904897b

--------------

## Ejemplo de trabajo

### Realizar operaciones en un equipo remoto

```PowerShell
cls
write-host "Ip del ordenador remoto"
$ipR=read-host

##Client
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
$udpclient=new-Object System.Net.Sockets.UdpClient
$b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('cls')"
$bytesSent=$udpclient.Send($b,$b.length,$endpoint)
$udpclient.Close()

while (1)
{

cls

Write-Host "Seleccione una opcion"

echo "1 - Sistema de archivos"
echo "2 - Agregar/eliminar software"
echo "3 - Actualizacion"
echo "4 - Gestion de procesos"
echo "5 - Programacion de tareas"
echo "6 - Gestion de usuarios"
echo "7 - Gestion de almacenamiento"
echo "8 - Gestion de red"
echo "9 - Copias de seguridad"
echo "10 - Reparacion del sistema"
echo "11 - Rendimiento del sistema"
echo "12 - Salir"

$prue1 = Read-Host
switch ( $prue1 )
    {
        1{
            cls
            Write-Host "Seleccione una opcion"
            echo "1 - Listar"
            echo "2 - Crear"
            echo "3 - Abrir"
            echo "4 - Eliminar"
            $selcec=Read-Host
            switch ( $selcec )
            {
                1{
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=[Text.Encoding]::ASCII.GetBytes('Get-ChildItem')
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                    Pause
                }
                2{
                    $type=Read-Host "Escriba que tipo desea crear (File o Directory)"
                    $name=Read-Host "Escriba el nombre del $type"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('New-Item -ItemType $type -Name $name')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                    Pause
                }
                3{
                    $name1=Read-Host "Nombre del archivo que desea abrir"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('start $name1')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                4{
                    ls
                    $name2=Read-Host "¿Qué desea eliminar?"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Remove-Item $name2')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
            }                   
        }
        2{
            cls
            $nombre=Read-Host "Introduzca nombre del .msi que desee instalar"
            ##Client
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('msiexec.exe /package C:\windows\Installer\($nombre)')"
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()
        Pause
        }
        3{
            cls
            echo "1 - Instalar"
            echo "2 - Desinstalar"
            Write-Host "Seleccione una opción"
            $actuali=Read-Host
            switch ($actuali)
            {
                1{
                    Write-Host "Como desea que se realize"
                    echo "1 - Normal"
                    echo "2 - En silencio"
                    $modo=Read-Host
                    switch ($modo)
                    {
                        1{
                            Write-Host "Escriba el nombre de la actualizacion"
                            $nombre=Read-Host
                            ##Client
                            $port=2020
                            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                            $udpclient=new-Object System.Net.Sockets.UdpClient
                            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre')"
                            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                            $udpclient.Close()
                           
                        }
                        2{
                            Write-Host "Eliga la opción desea"
                            echo "1 - No reiniciarse al terminar"
                            echo "2 - Pedir confirmación antes de reiniciar"
                            echo "3 - Obligar a que se cierren todas las aplicaciones y se reinicie"
                            $Smodo=Read-Host
                            $Nombre=Read-Host
                            switch($Smodo)
                            {
                                1{
                                    ##Client
                                    $port=2020
                                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                                    $udpclient=new-Object System.Net.Sockets.UdpClient
                                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /quiet /norestart')"
                                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                                    $udpclient.Close()
                                    
                                }
                                2{
                                    ##Client
                                    $port=2020
                                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                                    $udpclient=new-Object System.Net.Sockets.UdpClient
                                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /quiet /warnrestart')"
                                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                                    $udpclient.Close()                                    
                                }
                                3{
                                    ##Client
                                    $port=2020
                                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                                    $udpclient=new-Object System.Net.Sockets.UdpClient
                                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /quiet /forcerestart')"
                                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                                    $udpclient.Close()                                    
                                }
                            }
                        }
                    }
                }
                2{
                    cls
                    echo "1 - Normal"
                    echo "2 - Paquete asociado con el número de actualización"
                    Write-Host "Seleccione una opción"
                    $modo=Read-Host
                    switch ($modo)
                    {
                        1{
                            ##Client
                            $port=2020
                            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                            $udpclient=new-Object System.Net.Sockets.UdpClient
                            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /unistall')"
                            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                            $udpclient.Close()
                        }
                        2{
                            ##Client
                            $port=2020
                            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                            $udpclient=new-Object System.Net.Sockets.UdpClient
                            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /unistall /kb')"
                            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                            $udpclient.Close()
                        }
                    }
            }
            }
            puase
        }
        4{
            cls
            echo "1 - Iniciar un proceso"
            echo "2 - Mostrar solo Nombres"
            echo "3 - Mostrar proceso de cierto programa"

            $sele=Read-Host
            switch ( $sele )
            {
                1{
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('wusa $nombre /quiet /norestart')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                } 
                2 {
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-Process | select Name')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                3 {
                    $selprog=Read-Host "Escriba el nombre del programa"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-Process | Select-String $selprog')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
            }
        }
        5{
            cls
            $program=Read-Host "que programa desea abrir"
            $time=Read-Host "a que hora"
            $nomre=Read-Host "escriba el nombre de la tarea"
            $action=New-ScheduledTaskAction -Execute $program
            $trigger=New-ScheduledTaskTrigger -Daily -At $time
            ##Client
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Register-ScheduledTask -Action $action -Trigger $trigger -TaskName $nomre')"
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()           
            Pause
            
        }
        6{
            cls
            echo "1 - Crear usuario"
            echo "2 - Eliminar usuario"
            echo "3 - Crear grupo"
            echo "4 - Ver miembros de un grupo"
            echo "5 - Eliminar grupo"
            $opcion=Read-Host "Eliga una opcion"
            switch ($opcion)
            {
            1{
                $nameuser=Read-Host "Nomre del nuevo usuario"
                $pass=Read-Host "Introduzca contraseña"
                $pass1=ConvertTo-SecureString $pass -asplaintext -force
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('New-LocalUser $nameuser -Password $pass1')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()                
            }
            2{
                $usuer=Read-Host "Nombre del usuario"
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Remove-LocalUser -Name $usuer')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()                
            }
            3{
                $group=Read-Host "Nombre para el grupo"
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('New-LocalGroup -Name $group')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()                
            }
            4{
                $Ngroup=Read-Host "Nombre del grupo"
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-LocalGroupMember -Name $Ngroup')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()                
            }
            5{
                $Rgroup=Read-Host "Nombre del grupo que vaya a eliminar"
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-LocalGroupMember -Name $Rgroup')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()                
            }
            }
        }
        7{
            cls
            echo "1 - Particionar"
            echo "2 - Desfragmentar"
            echo "3 - Convertir sistemas de archivo"
            echo "4 - Cifrar"
            echo "5 - Descifrar"
            Write-Host  "Seleccione una opción"
            $almacenamiento=Read-Host
            switch ($almacenamiento)
            {
                1{
                    Write-Host "ADVERTENCIA: Nunca poner el numero '0'"
                    $NumeroD=Read-Host "Introduzca número del disco"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('New-Partition -DiskNumber $NumeroD -UseMaximumSize -AssignDriveLetter')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                2{
                    $letra=Read-Host "Letra del disco"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Optimize-Volume $letra -Defrag')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                    Disable-BitLocker 
                    Pause
                }
                3{
                    $letra=Read-Host "Letra del disco"
                    $tipo=Read-Host "Que formato desea"                    
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Format-Volume -DriveLetter $letra -FileSystem $tipo')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                    Pause
                }
                4{
                    $letra=Read-Host "Inroduzca letra del disco"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Enable-BitLocker -MountPoint $letra -RecoveryPasswordProtector -UsedSpaceOnly -Verbose')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                5{
                    $letra=Read-Host "Introduzca letra del disco"
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Disable-BitLocker -MountPoint $letra')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
            }
              
        }
        }
        8{
            cls
            echo "1 - Saber ip"
            echo "2 - Hacer ping"
            $op=Read-Host "Seleccione una opcion"
            Switch ( $op )
            {
            1{
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('ipconfig')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()
                Pause
            }
            2{
                $ip=Read-Host "Introduzca IPv4"
                ##Client
                $port=2020
                $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                $udpclient=new-Object System.Net.Sockets.UdpClient
                $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('ping $ip')"
                $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                $udpclient.Close()
                Pause
            }
            }
        }
        9{
            cls
            Write-Host "Se recomienda que ponga la ruta y para quedarsela usted la meta en una carpeta compartida"
            $namea=Read-Host "Nombre del archivo que desea hacer copia de seguridad"
            $ruta=Read-Host "Ruta donde desea que este la copia de seguridad"
            ##Client
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Copy-Item $namea $ruta')"
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()            
            Pause
        }
        10{
            cls
            Write-Host "Seleccione una opción"
            echo "1 - Ver puntos de restauracion"
            echo "2 - Restaurar un punto"
            $opcion=Read-Host
            switch ($opcion)
            {
                1{        
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-ComputerRestorePoint')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()
                }
                2{
                    Write-Host "Seleccione una opción"
                    echo "1 - Ultimo punto"
                    echo "2 - Restaura cierto punto"
                    $opcion=Read-Host
                    switch ($opcion)
                    {
                        1{
                            ##Client
                            $port=2020
                            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                            $udpclient=new-Object System.Net.Sockets.UdpClient
                            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-ComputerRestorePoint -LastStatus')"
                            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                            $udpclient.Close()
                        }

                        2{
                            Write-Host "Ponga el numero de restauración"
                            $punto=Read-Host
                            ##Client
                            $port=2020
                            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                            $udpclient=new-Object System.Net.Sockets.UdpClient
                            $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Restore-Computer -RestorePoint $punto')"
                            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                            $udpclient.Close()                   
                        }
                    }
                }
            }
            Pause
        }
        11{
            cls
            echo "1 - Monitorizar procesos"
            echo "2 - Monitorizar procesos Avanzado"
            echo "3 - Ver todos los nombres de los contadores de rendimiento"
            $seleccionar=Read-Host "Seleccione una opción"
            switch ( $seleccionar )
            {
                1{
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port
                    )
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-Process')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                2{
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-WmiObject -Class win32_process')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
                3{
                    ##Client
                    $port=2020
                    $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
                    $udpclient=new-Object System.Net.Sockets.UdpClient
                    $b=Invoke-Expression -Command "[Text.Encoding]::ASCII.GetBytes('Get-Counter -ListSet * | Sort-Object CounterSetName | Format-Table CounterSetName')"
                    $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
                    $udpclient.Close()                    
                    Pause
                }
            }
        }
}
if( $prue1 -eq "12" )
        {
            cls
            ##Client
            $port=2020
            $endpoint = new-object System.Net.IPEndPoint ([IPAddress]$ipR,$port)
            $udpclient=new-Object System.Net.Sockets.UdpClient
            $b=[Text.Encoding]::ASCII.GetBytes('break')
            $bytesSent=$udpclient.Send($b,$b.length,$endpoint)
            $udpclient.Close()
            break
        }
}
```

-----------
-----------

# Modelos de examen de la asignatura de Implantación de Sistemas Operativos (ISO) de 1º de Administración de Sistemas Informáticos en Red (ASIR) tercera evaluación
- Modelo 1 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-1
- Modelo 2 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-2
- Modelo 3 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-3
- Modelo 4 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-4
- Modelo 5 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-5
- Modelo 6 https://github.com/jesusninoc/ClasesISO/blob/master/2021-05-27.md#modelo-6

-----------------

# Modelo 1

## Tener en cuenta:
- Tener varias máquinas con varias IP's
- Se pueden utilizar varios nombres de equipos (hosts)
- Compartir carpetas en Linux
- Acceder a las carpetas en Linux desde Windows

## 1. Analizar ficheros DLL en todos los equipos de la red
```PowerShell
123..125 | %{"192.168.104." + $_}

123..125 | %{
$ruta="\\192.168.104." + $_ +"\c$\*.dll"
$ruta
}

123..125 | %{
$ruta="\\192.168.104." + $_ +"\c$\*.jes"
ls $ruta
}

1..40 |  %{Invoke-Command -ComputerName ("192.168.204." + $_) -ScriptBlock {hostname}}

Invoke-Command -ComputerName dc1 -ScriptBlock {hostname}

gc .\equipos1.txt | % {
    $llistar="\\"+$_+"\c$"
    ls $llistar | select name,FullName
} | Group-Object name | select Count,Group | where count -eq 1
```
### Enable and Use Remote Commands in Windows PowerShell
https://technet.microsoft.com/en-us/library/ff700227.aspx
### How to Add a Computer to the TrustedHosts List
```PowerShell
set-item wsman:\localhost\Client\TrustedHosts -value "ABANTO"
```
### Listar funciones exportadas de un archivo DLL con DUMPBIN desde PowerShell
https://www.jesusninoc.com/04/19/listar-funciones-exportadas-de-un-archivo-dll-con-dumpbin-desde-powershell/

## 2. Analizar ficheros DLL en todos los equipos de la red, comprobar que ha cambiado una integridad y copiar el fichero que ha cambiado
### En PowerShell
```PowerShell
mkdir dlls

cd dlls

"dll1" | Out-File dll1.dll
"dll2" | Out-File dll2.dll

# Recorrrer una a una dll
ls *.dll | %{$_}

# Hacer hash de cada dll
ls *.dll | %{Get-FileHash $_.FullName | Select-Object Hash}

# Hacer hash de cada dll ruta por red
ls '\\localhost\c$\Users\juan\dlls' *.dll | %{Get-FileHash $_.FullName | Select-Object Hash,Path}

# Guardar hash
ls '\\localhost\c$\Users\juan\dlls' *.dll | %{Get-FileHash $_.FullName | Select-Object Hash,Path | Out-File listado.txt -Append}

# Ver listado
gc .\listado.txt

# Modificar dll y detectar el cambio, después mover la dll, solución: el hash de cada dll no se encuentra en el fichero listado.txt, eso quiere decir que se ha modificado y hay que copiar a la carpeta compartida en Linux
# Modificar dll
"dll6" | Out-File dll1.dll

ls '\\localhost\c$\Users\juan\dlls' *.dll | %{
    if((gc .\listado.txt) -match (Get-FileHash $_.FullName | Select-Object Hash).hash)
    {
    }
    else
    {
        $_.Name
        "Dll se ha modificado"
    }
}


# Meter el código anterior en el recorrido que cada alumno tenga
123..125 | %{
$ruta="\\192.168.104." + $_ +"\c$\*.dll"
ls $ruta -recurse
}

# Almacenar el hash de la dll para todos los equipos de la red
foreach($equipo in gc .\equipos1.txt) {
    $llistar="\\"+$equipo+"\c$"
    ls $llistar -recurse *.dll | %{
        $valorse = Get-FileHash ($_ | select FullName).FullName
        $valorse.path+"|"+$valorse.Hash | Out-File hasehees.txt
    }
}

# Verificar si una dll no ha cambiado su hash
gc .\hasehees.txt | %{
    if($_.split("|")[0].contains("jawt.dll"))
    {
        if($_.split("|")[1] -eq (Get-FileHash "\\ABANTOS21\c$\Cache\pc-client.exe-16.3.0.37857\runtime\jre\bin\jawt.dll" | select hash).hash)
        {
            "CORRECTO"
        }
    }
}
```
#### Se puede crear una dll y modificar una función para comprobar que la integridad falla
* https://www.jesusninoc.com/11/26/crear-compilar-y-ejecutar-una-dll-con-microsoft-visual-c-que-ejecute-un-cmdlet-de-powershell/
* https://www.jesusninoc.com/04/19/listar-funciones-exportadas-de-un-archivo-dll-con-dumpbin-desde-powershell/
* https://www.jesusninoc.com/04/21/obtener-los-nombres-de-las-funciones-exportadas-de-un-archivo-dll-con-dumpbin-desde-powershell-explicacion-paso-a-paso-del-script/

### En Linux
https://github.com/jesusninoc/Bash/blob/master/Ficheros/EjemploIntegridad.sh

## 3. Puedes saber qué fichero DLL están funcionando en el equipo utilizando la red
```PowerShell
(Get-Process -ComputerName .).Modules
(Get-Process -ComputerName .).Modules | where ModuleName -eq  sxs.dll
```

## 4. Detectar que una aplicación tiene tráfico de red (filtro por puerto)
### Tshark Command Examples
https://linuxsimba.com/tshark-examples

```PowerShell
$filterUDP = ''
$filterTCP = ''
ps | where ProcessName -eq 'chrome' | %{
    Get-NetUDPEndpoint | where OwningProcess -EQ $_.Id | select LocalPort | % {
        $filterUDP = $filterUDP+'(udp.port == '+$_.LocalPort+') or'
    }
    
    Get-NetTCPConnection | where OwningProcess -EQ $_.Id | select LocalPort | % {
        $filterTCP = $filterTCP+'(tcp.port == '+$_.LocalPort+') or'
    }
    
    
}
$filterUDP = $filterUDP.substring(0, $filterUDP.Length-3)
$filterTCP = $filterTCP.substring(0, $filterTCP.Length-3)

$filter = $filterUDP+' or '+$filterTCP

net use \\192.168.104.129\Prueba-share-samba /user:root 1234

.\tshark.exe -i 'ethernet 2' -Y $filter > \\192.168.104.129\Prueba-share-samba\test.txt
```

-----------------

# Modelo 2

## Tener en cuenta
- Controlar y gestionar el uso del hardware del ordenador.
- Administrar la ejecución de los procesos.
- Controlar el acceso de los programas o los usuarios a los recursos del sistema.
- Particionado del disco duro.
- Registros (logs) del sistema.
- Configuración del protocolo TCP/IP en un cliente de red.
- Configuración de la resolución de nombres.
- Ficheros de configuración de red.
- Gestión de sistemas de archivos.
- Permisos locales de acceso a ficheros y directorios.
- Planes de copias de seguridad y restablecimiento.
- Compresión de datos.
- Permisos de red. Permisos locales.
- Registros de sucesos.
- Monitorización de sucesos.

## Imprescindible
- Tener varias máquinas con varias IP's
- Se pueden utilizar varios nombres de equipos (hosts)
- Compartir carpetas en Linux
- Acceder a las carpetas en Linux desde Windows

## Caso web periódico

### Eres el nuevo administrador de sistemas del diario el Universo. El diario funciona así: los periodistas sus ficheros HTML a sus carpetas en la red mediante un interfaz web (una Intranet). Cada periodista ve sus propios ficheros y no ve los de sus compañeros. Por ejemplo: Juan crea la página 1 del periódico y sube dicha página al servidor web.

## Resuelve lo siguiente:
1) Junta todas las páginas del periódico de todos los periodistas.
```PowerShell
mkdir usuario1; cd usuario1
"htmlkljsdafflkjsadfljsdaf" | Out-File pagina1.html
cd ..
mkdir usuario2; cd usuario2
"htmlkljsdafflkjsadfljsdaf" | Out-File pagina2.html
cd ..

ls *.html -recurse | %{
    $periodidcocomp = $periodidcocomp + (gc $_)
}

$periodidcocomp | out-file periodicocompleto.html
```
2) Haz copias de seguridad para diferentes momentos del día y al final del día haz copia de todo el periódico completo.
```PowerShell
(Get-Date).ToString("yyyyMMddhh")

$fecha = (Get-Date).ToString("yyyyMMddhh")
mkdir ($fecha) -force
cd $fecha

ls *.html -recurse | %{
    copy $_ $fecha
}
```
3) Incidencia. Alguien ha mandado imprimir el periódico entero. Tienes que pararlo porque no es el momento de imprimirlo.
```PowerShell
##Client
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Loopback,$port)
$udpclient=new-Object System.Net.Sockets.UdpClient
#$perio = gc .\periodicocompleto.html
$b=[Text.Encoding]::ASCII.GetBytes("gc perio.html | out-printer")
$bytesSent=$udpclient.Send($b,$b.length,$endpoint)
$udpclient.Close()
##Server
while(1)
{
$port=2020
$endpoint = new-object System.Net.IPEndPoint ([IPAddress]::Any,$port)
$udpclient=new-Object System.Net.Sockets.UdpClient $port
$content=$udpclient.Receive([ref]$endpoint)
$udpclient.Close()
if([Text.Encoding]::ASCII.GetString($content) | select-string "print")
{
    "ha mandado imprimir"
}
}
```
4) Opcional. El periódico automático. Crear cada página HTML utilizando una base de datos
* https://www.jesusninoc.com/09/20/crear-un-fichero-html-con-el-contenido-de-la-tabla-posts-de-wordpress-con-powershell/

-----------------

# Modelo 3

## Utiliza TODO lo que hemos visto en clase:
- Auditar
- Firewall
- Recuperación MBR
- VPN
- Interfaz de red duplicado
- Conexiones seguras
- Monitorizar
- Gestión de discos
- Netsh
- SSH + SCP
- Carpetas compartidas
- Permisos
- FTP
- GPO
- Mapa de red

## Preguntas:
- Explica cómo puedes saber quién accede a una carpeta compartida en Windows.
```PowerShell
Get-EventLog -LogName security | select Message | select-string "\\localhost\ejemplo"
```
- Explica un procedimiento de copias de seguridad que te parezca lo más óptimo posible, ten en cuenta:
  - Windows o Linux.
    - https://www.jesusninoc.com/11/26/database-backup-program-scripts-examples/
    - https://www.jesusninoc.com/03/12/select-files-between-two-dates-and-copy-them/
  - Dejar programada la acción.
    - https://www.jesusninoc.com/03/01/tareas-programadas-en-powershell/
  - Comprimir y descomprimir
    - https://www.jesusninoc.com/03/15/create-new-compress-archive-file/
    - https://www.jesusninoc.com/02/14/descomprimir-archivos/
  - Cifrar el contenido, método sencillo o complicado.
    - https://www.jesusninoc.com/01/23/cifrar-con-un-algoritmo-sencillo-el-nombre-y-el-contenido-de-un-fichero-de-texto/
  - También puedes añadir otros elementos relacionados con la copia de seguridad como la reparación
  - Funciones simples y complejas
```PowerShell
##########################
# Funciones simples
##########################
function crearestructura()
{
    "archivo1" > archivo1.txt
    "archivo2" > archivo2.txt
    mkdir copia -force

    $fecha = (Get-Date).ToString("yyyyMMdd")
    cd copia
    mkdir ($fecha) -force
}

crearestructura

function copiararchivos()
{
    $fecha = (Get-Date).ToString("yyyyMMdd")
    ls *.txt | %{
        cp $_ copia\$fecha -force
    }
}

copiararchivos

function recuperar
{
  param($fichero)
  begin
  {
  }
  process
  {
    Expand-Archive -LiteralPath $fichero -DestinationPath desco\
  }
  end
  {
  }
}

recuperar .\comprimido.zip

##############################################################################

##########################
# Función compleja
##########################
function copiaseguridad
{
  param()
  begin
  {
    "archivo1" > archivo1.txt
    "archivo2" > archivo2.txt
    mkdir copia -force
    $fecha = (Get-Date).ToString("yyyyMMdd")
    mkdir copia\$fecha -force
  }
  process
  {
    $fecha = (Get-Date).ToString("yyyyMMdd")
    ls *.txt | %{
        cp $_ copia\$fecha\ -force
    }
  }
  end
  {
    $fecha = (Get-Date).ToString("yyyyMMdd")
    ls copia\$fecha
    Compress-Archive -LiteralPath copia\$fecha –CompressionLevel Optimal -DestinationPath comprimido.zip -Force
  }
}
copiaseguridad
```
- Se ha producido una infección en un sistema operativo Windows,
  - ¿qué elementos comprobarías para detectar dicha infección?
      - https://www.jesusninoc.com/07/11/analisis-de-procesos-y-conexiones-de-red-con-powershell/
  - ¿cómo impides que se produzcan infecciones el sistema operativo?
  - ¿Windows dispone de herramientas centralizadas para evitarlo?

```PowerShell
function monitorizar
{
  param()
  begin
  {
  }
  process
  {
    foreach($conex in @(netstat -ano))
    {
        foreach($proceso in ps | where id -EQ ((Get-Process -name chrome | sort cpu -Descending | select -First 2)[0].id))
        {
            if($conex -match $proceso.Id -and $proceso.Id -ne 4 -and $proceso.Id -ne 0)
            {
                write-host $conex “-PROCESO->” $proceso.Name $proceso.Id
            }
        }
    }
  }
  end
  {
  }
}

monitorizar
```
  
- Explica todo el proceso para realizar una clonación.
- Explica todo lo que sepas sobre permisos en Windows.
- ¿Cómo puedes hacer una sincronización en Linux?, ¿puedes hacerla entre equipos?, ¿cómo?
- ¿Un driver falla, qué haces para arrancar el sistema?
- ¿Un componente gráfico, qué haces para arrancar el sistema?
- Se puede lograr utilizar carpetas compartidas de Windows en Linux y que se queden arrancadas desde que se carga Linux.
- Prepara un script para guardar los logs que sean problemáticos todos los días de la semana, se tienen que enviar a una carpeta compartida o utilizando un protocolo seguro (entorno lo más seguro que puedas), hay que colocarlos de forma ordenada.
    - https://www.jesusninoc.com/07/10/10-gestion-del-rendimiento-en-powershell/
- Explica para qué sirven las auditoría y qué relación tiene con los permisos.
- ¿Qué hace el siguiente script? (explica en detalle el código)
```PowerShell
Import-Module ActiveDirectory
Import-Csv C:\Users\Administrador\Desktop\CrearAlumnos\Mis_Usuarios.csv |%{
$nombreco=$_.FirstName + " " + $_.LastName
$ru="OU=" + $_.Curso + ",OU=FP,OU=Alumnos,OU=Usuarios,DC=retared,DC=local"
$HomeDirectory="\\alumnos\fp\" + $_.Curso + "\" + $_.sAMAccountname
mkdir $HomeDirectory
$HomeDirectory
$HomeDrive=’Q:’
New-ADUser -Name $_.FirstName -SamAccountName $_.sAMAccountname -HomeDrive $HomeDrive –HomeDirectory $HomeDirectory -DisplayName $nombreco -Enabled $true -ChangePasswordAtLogon $false -AccountPassword (ConvertTo-SecureString $_.Password -AsPlainText -force) -PassThru -UserPrincipalName $_.sAMAccountname -Path $ru
$usereta="retared\" + $_.sAMAccountname + ":F"
$HomeDirectory + "-" + $usereta
cacls $HomeDirectory /G $usereta /E
Add-ADGroupMember -Identity "CN=alumni,CN=Builtin,DC=reto,DC=local" $_.sAMAccountname
}
```

-----------------

# Modelo 4

## Consideraciones previas
- Lo primero que tienes que tener en cuenta es el rango de IP que vas a utilizar, todos sois distintos, se configura la IP con Windows y Linux.
- Lo que sepas expresar con scripts hazlo, lo que no, lo explicas.
- Utiliza bien las palabras y no te las inventes.
- Piensa en la red que tenemos en el Centro para resolver algunas preguntas.

## Utiliza TODO lo que hemos visto en clase:
- Auditar
- Firewall
- Recuperación MBR
- VPN
- Interfaz de red duplicado
- Conexiones seguras
- Monitorizar
- Gestión de discos
- Netsh
- SSH + SCP
- Carpetas compartidas
- Permisos
- FTP
- GPO
- Mapa de red

## Preguntas:
### Explica cómo puedes saber quién accede a una carpeta compartida en Windows.
### Explica qué herramientas conoces para monitorizar en Windows y en Linux.
### Qué hay que hacer para lograr utilizar carpetas compartidas de Windows en Linux y que se queden arrancadas desde que se carga Linux.
### Prepara un script para guardar los logs que sean problemáticos todos los días de la semana, se tienen que enviar a una carpeta compartida o utilizando un protocolo seguro (entorno lo más seguro que puedas), hay que colocarlos de forma ordenada.
### Explica un procedimiento de copias de seguridad que te parezca lo más óptimo posible, ten en cuenta:
  - Windows o Linux.
  - Dejar programada la acción.
  - Cifrar el contenido, método sencillo o complicado.
  - Dejar la carpeta oculta, comando attrib.
  - También puedes añadir otros elementos relacionados con la copia de seguridad como la reparación.
### Se ha producido una infección en un sistema operativo Windows, ¿qué elementos comprobarías para detectar dicha infección?, ¿cómo impides que se produzcan infecciones el sistema operativo?, ¿Windows dispone de herramientas centralizadas para evitarlo?
#### Preparar un script que haga una correcta monitorización del sistema, teniendo en cuenta:
##### - Un proceso que no se comporta como siempre es raro.
```PowerShell
$proceso1=(gps).name
start notepad
Start-Sleep -Seconds 3
$proceso2=(gps).name
Compare-Object -ReferenceObject $proceso1 -DifferenceObject $proceso2
  ```
 ##### - Un proceso que abre muchos hilos es raro.
  ```PowerShell
  Get-Process | %{
    $_.name, $_.Threads.Count
}
  ```
 ##### - Un proceso que abre muchas comunicaciones es raro.
 ##### - Un proceso que consume fuera de lo normal es raro.
 ##### - Un proceso que se activa a una hora extraña es raro.
  ```PowerShell
  Get-EventLog -LogName Security -InstanceId 4688
  Get-EventLog Application | Where-Object Message -Match "explore" 
  ```
 ##### - Caso práctico: “RATas inminentes” (I) https://www.securityartwork.es/2018/05/28/caso-practico-ratas-inminentes-i/?utm_source=dlvr.it&utm_medium=twitter
### Script para simular una infección y una posterior desinfección.
### Puedes explicarme algún sistema distribuido que relacione las cosas que hemos visto en clase.

-----------------

# Modelo 5

## Consideraciones previas
- Lo primero que tienes que tener en cuenta es el rango de IP que vas a utilizar, todos sois distintos, se configura la IP con Windows y Linux.
- Lo que sepas expresar con scripts hazlo, lo que no, lo explicas.
- Utiliza bien las palabras y no te las inventes.
- Piensa en la red que tenemos en el Centro para resolver algunas preguntas.

## Utiliza TODO lo que hemos visto en clase:
- Auditar
- Firewall
- Recuperación MBR
- VPN
- Interfaz de red duplicado
- Conexiones seguras
- Monitorizar
- Gestión de discos
- Netsh
- SSH + SCP
- Carpetas compartidas
- Permisos
- FTP
- GPO
- Mapa de red

## Preguntas:
### Explica cómo puedes saber quién accede a una carpeta compartida en Windows.
### Explica qué herramientas conoces para monitorizar en Windows y en Linux.
### Qué hay que hacer para lograr utilizar carpetas compartidas de Windows en Linux y que se queden arrancadas desde que se carga Linux.
### Prepara un script para guardar los logs que sean problemáticos todos los días de la semana, se tienen que enviar a una carpeta compartida o utilizando un protocolo seguro (entorno lo más seguro que puedas), hay que colocarlos de forma ordenada.
### Explica un procedimiento de copias de seguridad que te parezca lo más óptimo posible, ten en cuenta:
  - Windows o Linux.
  - Dejar programada la acción.
  - Cifrar el contenido, método sencillo o complicado.
  - Dejar la carpeta oculta, comando attrib.
  - También puedes añadir otros elementos relacionados con la copia de seguridad como la reparación.
### Se ha producido una infección en un sistema operativo Windows, ¿qué elementos comprobarías para detectar dicha infección?, ¿cómo impides que se produzcan infecciones el sistema operativo?, ¿Windows dispone de herramientas centralizadas para evitarlo?
#### Preparar un script que haga una correcta monitorización del sistema, teniendo en cuenta:
##### - Un proceso que no se comporta como siempre es raro.
```PowerShell
$proceso1=(gps).name
start notepad
Start-Sleep -Seconds 3
$proceso2=(gps).name
Compare-Object -ReferenceObject $proceso1 -DifferenceObject $proceso2
  ```
 ##### - Un proceso que abre muchos hilos es raro.
  ```PowerShell
  Get-Process | %{
    $_.name, $_.Threads.Count
}
  ```
 ##### - Un proceso que abre muchas comunicaciones es raro.
 ##### - Un proceso que consume fuera de lo normal es raro.
 ##### - Un proceso que se activa a una hora extraña es raro.
  ```PowerShell
  Get-EventLog -LogName Security -InstanceId 4688
  Get-EventLog Application | Where-Object Message -Match "explore" 
  ```
 ##### - Caso práctico: “RATas inminentes” (I) https://www.securityartwork.es/2018/05/28/caso-practico-ratas-inminentes-i/?utm_source=dlvr.it&utm_medium=twitter
### Script para simular una infección y una posterior desinfección.
### Puedes explicarme algún sistema distribuido que relacione las cosas que hemos visto en clase.

-----------------

# Modelo 6


## Explicar y realizar un script para cada una de las siguientes situaciones:

1. Cómo puedes saber quién accede a una carpeta compartida en Linux.
2. Realiza un procedimiento de copias de seguridad que te parezca lo más óptimo posible, ten en cuenta:
    - Windows o Linux.
    - Dejar programada la acción.
    - Cifrar el contenido, método sencillo o complicado.
    - Dejar la carpeta oculta, comando attrib.
    - También puedes añadir otros elementos relacionados con la copia de seguridad como la reparación.
3. Puedes explicar algún sistema distribuido que relacione las cosas que hemos visto en clase.
4. ¿Cómo puedes hacer una sincronización en Linux?, ¿cómo?
5. Se ha producido una infección en un sistema operativo Windows, ¿qué elementos comprobarías para detectar dicha infección?, ¿cómo impides que se produzcan infecciones el sistema operativo?, ¿Windows dispone de herramientas centralizadas para evitarlo?

## Ayuda
### LISTAR PROCESOS DE POWERSHELL CON NODE-POWERSHELL (NODE.JS)
https://www.jesusninoc.com/06/04/listar-procesos-de-powershell-con-node-powershell-nodejs/

### LISTAR PROCESOS DE POWERSHELL CON NODE-POWERSHELL (NODE.JS) Y MOSTRARLOS EN UNA WEB CON EXPRESS
https://www.jesusninoc.com/07/15/listar-procesos-de-powershell-con-node-powershell-node-js-y-mostrarlos-en-una-web-con-express/

### Ejemplo de NODE.JS (Crear una página web con información sobre cada equipo)
```JavaScript
const shell = require('node-powershell');
const express = require('express')
const app = express()
 
let ps = new shell({
  executionPolicy: 'Bypass',
  noProfile: true
});
 
ps.addCommand('$ComputerSystem=Get-WmiObject Win32_ComputerSystem;$BaseBoard=Get-WmiObject Win32_BaseBoard;$BIOS=Get-WmiObject Win32_BIOS;$Processor=Get-WmiObject Win32_Processor;[PSCustomObject]@{ Model = $ComputerSystem.Model; ManufacturerBoard = $BaseBoard.Manufacturer; BIOSVersion = $BIOS.SMbiosbiosversion; BIOSSerialNumber = $BIOS.serialnumber; ManufacturerProcessor=$Processor.Manufacturer; MaxClockSpeed=$Processor.MaxClockSpeed} | ConvertTo-Html')
ps.invoke()
.then(output => {
  console.log(output);
  app.get('/', function (req, res) {
    res.send(output);
  })  
})
.catch(err => {
  console.log(err);
  ps.dispose();
});
 
app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
})
```

### Ejemplo de NODE.JS (Crear una página web con información sobre procesos)
```JavaScript
const shell = require('node-powershell');
const express = require('express')
const app = express()

let ps = new shell({
  executionPolicy: 'Bypass',
  noProfile: true
});
 
ps.addCommand('Get-Process | ConvertTo-Html -Property Name, Path, Company')
ps.invoke()
.then(output => {
  console.log(output);
  app.get('/procesos', function (req, res) {
    res.send(output);
  })  
})
.catch(err => {
  console.log(err);
  ps.dispose();
});

let ps2 = new shell({
  executionPolicy: 'Bypass',
  noProfile: true
});
 
ps2.addCommand('Get-Service | ConvertTo-Html -Property Name, Path, Company')
ps2.invoke()
.then(output => {
  console.log(output);
  app.get('/servicios', function (req, res) {
    res.send(output);
  })  
})
.catch(err => {
  console.log(err);
  ps2.dispose();
});

app.listen(3000, function () {
  console.log('Example app listening on port 3000!')
})
```
